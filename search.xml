<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[element ui + nuxt + koa构建项目]]></title>
    <url>%2F2019%2F07%2F18%2Fnuxt-koa%2F</url>
    <content type="text"><![CDATA[1全局安装npx koa-generator 12npm install -g npxnpm install -g koa-generator 2.创建项目 1npx create-nuxt-app &lt;name&gt; 选择项： koa element-ui eslint axios 3.为防止编译出错安装npm instal --update-binary 4.运行 npm run dev 5.兼用es6:package.json 在dev&amp;start内后添加 --exec babel-node 根目录创建 .babelrc写 {&quot;presets&quot;:[&quot;es2015&quot;]} 然后安装 npm install babel-preset-es2015 提示：’babel-node’ 不是内部或外部命令，也不是可运行的程序解决： npm install babel-core babel-clifsevents报错：package.-lock.josn 目录下所有fsevents依赖删除完就好 6.安装scss/less: npm install sass-loader node-sass 7.安装eslint 1npm install eslint@^3.19.0 --save-dev]]></content>
      <categories>
        <category>工具/环境搭建</category>
      </categories>
      <tags>
        <tag>工具/环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB数据库安装]]></title>
    <url>%2F2019%2F07%2F05%2Fmongodb%2F</url>
    <content type="text"><![CDATA[最近做项目接触到MongoDB，这里简单做下笔记。 安装1.官网下载，根据电脑配置下载安装详情 这里我装在E盘 2.然后创建一个（mongodbdata）文件存放数据请注意，数据目录应该放在根目录下，否则启动失败这里我在E盘根目录下新建了一个mongodbdata目录 》db数据存放目录、log日志文件。新建mongod.cfg配置文件 配置内容如下 systemLog: destination: file path: e:\mongodbdata\log\mongod.log storage: dbPath: e:\mongodbdata\db 3.命令行下运行 MongoDB 服务器到MongoDB 目录的 bin 目录下打开命令窗口运行 1mongod --dbpath e:\mongodbdata\db mongodb默认连接端口27017，如果出现如图的情况，可以打开http://localhost:27017查看 但这样启动很麻烦。所以我们创建mongodb.bat文件，作为启动服务文件 4.这里在E盘创建一个mongo文件夹 创建mongodb.bat文件，作为启动服务文件（直接双击mongodb.bat文件启动）创建mongodb27017.bat文件，作为启动shell客户端的文件(即输入mongodb语句的dos窗口)mongodb.bat配置 1mongod --dbpath E:\mongodbdata mongodb27017.bat 1mongo 127.0.0.1:27017 先双击mongodb.bat文件，启动mongodb服务，如下图：在双击mogondb27017.bat文件，启动输入mongodb语句的服务，如下图：启动完毕！！！ 导入数据]]></content>
      <categories>
        <category>工具/环境搭建</category>
      </categories>
      <tags>
        <tag>工具/环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于koa]]></title>
    <url>%2F2019%2F07%2F04%2Fkoa%2F</url>
    <content type="text"><![CDATA[安装官网介绍：Koa 是一个新的 web 框架，通过利用 async 函数，Koa 帮你丢弃回调函数，并有力地增强错误处理。 Koa 并没有捆绑任何中间件， 而是提供了一套优雅的方法，帮助您快速而愉快地编写服务端应用程序。官网API koa用来承担服务器的作用。 koa-generator:安装: npm install -g koa-generator 创建项目 koa2 project 或 koa2 -e project ps: -e表示使用ejs模板引擎 安装依赖 cd project npm install 安装update-binary包 npm install --update-binary 启动app SET DEBUG=koa* npm start 对应命令:koa start (修改代码,应用不自更新)koa run dev (修改代码,应用自更新，建议使用)koa run prdkoa test nuxt+koa2配置环境创建文件nuxt-learn vue init nuxt-community/koa-template nuxt-learn 当npm install安装失败时，运行 nrm use npm（回车） nrm ls（选择当前npm安装源，重新安装即可） 如果安装后提示–update-binary字眼，则重新安装下 npm install –update-binary 如果提示 ajv-keywords@3.2.0 requires a peer of ajv@^6.0.0 but .字眼，则重新安装npm i ajv@^6 koa异步（async 和 await）我们这里举个小栗子在router下的index.js文件创建一个测试接口， 这里注意，async下可以不用await，但如果存在await则必须要有async。保存后查看控制台看服务端响应时间为1s左右 await关键字必须紧跟async关键字后面，不能单独出现； await关键字后面必须紧跟一个promise对象，如果不是，则系统会强制转化为promise; 如果存在多个await调用，则按照它们出现的顺序依次向下执行 koa中间件koa2中间件的使用原理，如同你贯穿一个洋葱，一层一层下去，最终还是会穿过初始的那一层，所以在引入时可以无序，但在使用’use’调用时，会按照顺序执行。能够实现这一切的，是在每个中间件函数中使用async与await关键字await.next()指当前中间件运行完毕后。进入下一个中间件你可以在pv()里面自行写方法最后在app.js中导入 const pv = require(&apos;./middleware/koa-pv&apos;) app.use(pv()) koa与MongoDB数据库连接先运行koa之后打开studio 3T（数据库可视化公交）连接上27017端口在项目文件下安装mongoose 1npm i mongoose 创建一个配置文件，对数据库进行一个配置 config.js配置如下： 123module.exports = &#123; dbs:&apos;mongodb://127.0.0.1.27017/dbs&apos; &#125; 在dbs下创建一个models目录放置数据项 回到koa文件下的app.js引入mongoos]]></content>
      <categories>
        <category>框架、工具/环境搭建</category>
      </categories>
      <tags>
        <tag>框架、工具/环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[嵌套路由nuxt-child组件（父子页面组件的传值）]]></title>
    <url>%2F2019%2F06%2F21%2Fnuxt-child%2F</url>
    <content type="text"><![CDATA[链接：nuxt文档相关文章 1.创建内嵌子路由，需要添加一个 Vue 文件，同时添加一个与该文件同名的目录用来存放子视图组件。这里在pages里新建一个fanil.vue、fanil文件夹 2.fanil.vue源码123456789101112131415161718192021222324252627282930313233&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;p&gt;Final Page&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;NuxtLink to=&quot;/&quot;&gt; Go to /home &lt;/NuxtLink&gt; &lt;/li&gt; &lt;li&gt; &lt;NuxtLink to=&quot;/fanil&quot;&gt; Go to /index &lt;/NuxtLink&gt; &lt;/li&gt; &lt;li&gt; &lt;NuxtLink to=&quot;/fanil/child&quot;&gt; Go to /child &lt;/NuxtLink&gt; &lt;/li&gt; &lt;li&gt; &lt;NuxtLink to=&quot;/fanil/child2&quot;&gt; Go to /child2 &lt;/NuxtLink&gt; &lt;/li&gt; &lt;/ul&gt; &lt;hr&gt; &lt;div class=&quot;box&quot;&gt; &lt;p&gt;嵌套子页面内容区&lt;/p&gt; &lt;!-- &lt;nuxt-child&gt;标签在父页面组件中相当于是子页面组件的占位符；嵌套中这个不可少 --&gt; &lt;nuxt-child keep-alive :foobar=&quot;123&quot;&gt;&lt;/nuxt-child&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 3.子组件默认页面index.vue(pages/fanil/index） 12345678910111213&lt;template&gt; &lt;div&gt; &lt;h2&gt;嵌套子组件中的默认页面index.vue&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; &#125;&lt;/script&gt;&lt;style scoped&gt; &lt;/style&gt; 4.child.vue(pages/fanil/child) 1234567891011121314&lt;template&gt; &lt;div&gt; &lt;h2&gt;嵌套子组件中的页面child&lt;/h2&gt; &lt;p&gt;foobar：&#123;&#123;foobar&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props:[&apos;foobar&apos;]&#125;&lt;/script&gt;&lt;style scoped&gt; &lt;/style&gt; 5.child2.vue(pages/fanil/child2) 12345678910111213&lt;template&gt; &lt;div&gt; &lt;h2&gt;嵌套子组件中的页面child2&lt;/h2&gt; &lt;p&gt;foobar：&#123;&#123;foobar&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props:[&apos;foobar&apos;]&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 最终效果：]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于vue环境配置]]></title>
    <url>%2F2019%2F05%2F16%2Fvueebook%2F</url>
    <content type="text"><![CDATA[方法一：父子组件传值 父组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 &lt;!--底部菜单栏 --&gt; &lt;menu-bar :ifTitleAndMenu=&quot;ifTitleAndMenu&quot; :defaultFontSize=&quot;defaultFontSize&quot; ref=&quot;menuBar&quot; @setFontSize=&quot;selecFont&quot; &gt;&lt;/menu-bar&gt;&lt;script&gt;import Epub from &apos;epubjs&apos;;import MenuBar from &apos;../components/MenuBar&apos;//电子书路径const DOWNLOAD_URL = &apos;/ebook.epub&apos;;global.epub = Epub;export default &#123; name:&apos;ebook&apos;, components: &#123; TitleBar, MenuBar &#125;, data()&#123; return &#123; ifTitleAndMenu:false, defaultFontSize:16 //默认字体大小 &#125; &#125;, methods: &#123; //字体大小设置 selecFont(fontSize)&#123; this.defaultFontSize = fontSize if(this.themes)&#123; this.themes.fontSize(fontSize + &apos;px&apos;) &#125; &#125;, //菜单栏显隐 showMenu()&#123; this.ifTitleAndMenu = !this.ifTitleAndMenu if(!this.ifTitleAndMenu)&#123; this.$refs.menuBar.hidesetting() &#125; &#125;, //电子书解析渲染 showEpub()&#123; //生成book对象 this.book = new Epub(DOWNLOAD_URL) //切记把路径放对象里面 //console.log(this.book) //通过renderTo()生成rendition对象，read为挂载的dom this.rendition = this.book.renderTo(&apos;read&apos;, &#123; width:window.innerWidth, height:window.innerHeight &#125;) //通过rendition.display()渲染电子书 this.rendition.display() //获取theme对象 this.themes = this.rendition.themes this.selecFont(this.defaultFontSize) &#125; &#125;, mounted() &#123; this.showEpub() &#125;&#125;&lt;/script&gt; 子组件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;div class=&quot;select-wrap&quot;&gt; &lt;div class=&quot;select&quot; v-for=&quot;(item, index) in fontSizeList&quot; :key = &quot;index&quot; @click=&quot;selecFontSize(item.fontSize)&quot; //点击进度条设置字体大小 &gt; &lt;div class=&quot;line&quot;&gt;&lt;/div&gt; &lt;div class=&quot;point-wrap&quot;&gt; &lt;div class=&quot;point&quot; v-show=&quot;defaultFontSize === item.fontSize&quot;&gt; &lt;div class=&quot;smallpoint&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;line&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt;export default &#123; props: &#123; ifTitleAndMenu:&#123; type:Boolean, default:false &#125;, defaultFontSize:Number &#125;, data()&#123; return &#123; isSettingShow:false, fontSizeList:[ &#123;fontSize: 12&#125;, &#123;fontSize: 14&#125;, &#123;fontSize: 16&#125;, &#123;fontSize: 18&#125;, &#123;fontSize: 20&#125;, &#123;fontSize: 22&#125; ] &#125; &#125;, computed:&#123; current()&#123; return store.state.defaultFontSize &#125; &#125;, methods: &#123; showsetting()&#123; this.isSettingShow = true &#125;, hidesetting()&#123; this.isSettingShow = false &#125;, selecFontSize(fontSize)&#123; this.$emit(&apos;setFontSize&apos;, fontSize) &#125; &#125;&#125;&lt;/script&gt;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex基础用例]]></title>
    <url>%2F2019%2F03%2F03%2Fvuexyl%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;Vue.use(Vuex)const state = &#123; count:0 &#125;,const mutations = &#123; add(state)&#123; state.count++ &#125;, dcre(state)&#123; state.count-- &#125;, &#125; const actions = &#123; add:(&#123; commit &#125;) =&gt; &#123; commit(&quot;add&quot;) &#125;, dcre:(&#123; commit &#125;) =&gt; &#123; commit(&quot;dcre&quot;) &#125; &#125;,export default new Vuex.Store(&#123; state, mutations, actions&#125;); 关于actions:官方文档是这么写的：Action 类似于 mutation，不同在于：Action 提交的是 mutation，而不是直接变更状态。Action 可以包含任意异步操作。 然后在组件中导入， 通过Action触发add、dcre方法 1234567891011121314151617181920212223&lt;template&gt; &lt;div&gt; &#123;&#123; $store.state.count &#125;&#125; &lt;button @click=&quot;add&quot;&gt;增加&lt;/button&gt; &lt;button @click=&quot;drce&quot;&gt;删减&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;import &#123; mapActions &#125; from &apos;vuex&apos;export default &#123; // ... methods: &#123; ...mapActions([ &apos;add: &apos;dcre&apos;, // `mapActions` 也支持载荷： &apos; dcre&apos; // 将 `this. dcre(amount)` 映射为 `this.$store.dispatch(&apos; dcre&apos;, amount)` ]), ...mapActions(&#123; add: &apos;increment&apos; // 将 `this.add()` 映射为 `this.$store.dispatch(&apos;increment&apos;)` &#125;) &#125;&#125; vuex多业务模块用例多业务模块时，不同模块间数据并不相干，将前台state拆成多个module方便代码维护；通过这种思想使各功能模块高内聚低耦合 举个例子：1.创建store文件 》module文件（放置不同数据块）、index.js2.module文件 放置a.js、b.jsindex.js入口文件导入数据块a,b3.在main.js入口文件里修改 store默认导入路径，修改如下 4.最后在组件中引入数据]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于升级vue-cli3.0踩坑记录]]></title>
    <url>%2F2019%2F01%2F11%2Fazvue%2F</url>
    <content type="text"><![CDATA[最近升级vue-cli3.0最新版本的时候遇到很多坑，绕了很多弯。查了很多资料，最终解决。记录一下遇到的问题，以防以后再次发生。 1.升级@vue/cli 3.x 需要安装node.js最新版本。卸载重新安装。我这里安装的是node.js10.15.1 卸载了vue-cli2.X版本 npm uninstall vue-cli -g //卸载vue-cli旧版本 安装 npm install -g @vue/cli 一直安装失败。在命令窗口vue+回车后发现没安装上。 尝试执行npm install -g vue-cli安装旧版本也安装失败。估计跟版本升级有关。 于是重新安装淘宝npm镜像 npm install -g cnpm –registry=https://registry.npm.taobao.org 以为这下可以了吧~~ 然而再次安装@vue/cli依旧失败。。。。。 百度下原因可能是安装路径出现错误。链接：vue-cli3.0升级失败，vue-cli卸载不掉，vue-cli升级不了3.0 2. 修改安装路径 默认装在C:\Users\Administrator\AppData\Roaming\npm 因为node.js安装在D盘，修改全局安装路径。 打开“计算机” 》 “高级系统设置” 》 “环境变量” 》“path” 修改路径 D:nodejs\node_global 3.设置npm默认安装路径 npm config set prefix “D:\nodejs\node_global”npm config set cache “D:\nodejs\node_cache” 重新安装@vue/cli 3.x ，阿西吧，又失败了（n遍失败）。 然鹅，我一直忽略一个问题 ！！！ 输入cnpm -v 报cnpm不是内部命令也不是外部命令输入vue+回车 不是内部命令 解决方法： 找到npm目录，放置在D:\nodejs\node_global下面，我是选择安装在这。 再找到cnpm目录，同样D:\nodejs\node_global下面，把cnpm和npm放在一个目录* 返回上一级D:\node\node_global 里面有npm和npm.cmd 搜索cnpm.cmd 把cnpm和cnpm.cmd放在D:\node\node_global里 4.重新安装 vue npm install vue 太慢请安装cnpm install vue 5.安装vue-cli 直接安装最新的包 npm install -g @vue/cli 用 vue –version这个命令来检查其版本是否正确 (3.x)： 终于安装成功！！！！ (๑╹◡╹)ﾉ”””彩蛋： 安装后创建一个项目 vue create hello-world 选择 “default (babel, eslint)” 默认的设置，非常适合快速创建一个新项目的原型。 然后 cd hello-worldnpm run serve 运行效果如下： 可以通过 vue ui 命令以图形化界面创建和管理项目： vue ui]]></content>
      <categories>
        <category>工具/搭建环境</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue客户端存储]]></title>
    <url>%2F2018%2F12%2F11%2Fvuekhd%2F</url>
    <content type="text"><![CDATA[客户端存储关于客户端存储：通过把数据存储在浏览器中，用户不必每次都向服务器请求获取同一个信息。离线时，使用本地存储的数据而不是向远端服务器上请求数据就显得非常有用。 Local Storage 适合存储你希望进行持久化的较小数据集，比如用户偏好设置或表单数据。 注意：存储对象和数组这样更复杂的数据，必须使用 JSON 来对数据进行序列化和反序列化。 太多废话了直接正题 我是一个小案例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;template&gt; &lt;div class=&quot;tab&quot;&gt; &lt;h2&gt;便签&lt;/h2&gt; &lt;p&gt; &lt;input v-model=&quot;newValue&quot; placeholder=&quot;请输入...&quot;&gt; &lt;button @click=&quot;addTab&quot;&gt;AddTab&lt;/button&gt; &lt;/p&gt; &lt;ul&gt; &lt;li v-for=&quot;(value, key) in items&quot;&gt; &lt;span&gt;&#123;&#123; value &#125;&#125;&lt;/span&gt; &lt;button @click=&quot;removeTab(key)&quot;&gt;RemoveTab&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data()&#123; return &#123; items:[], newValue:null &#125; &#125;, mounted()&#123; if(localStorage.getItem(&quot;items&quot;))&#123; try&#123; this.items = JSON.parse(localStorage.getItem(&quot;items&quot;)); &#125; catch(e)&#123; localStorage.removeItem(&apos;items&apos;); &#125; &#125; &#125;, methods:&#123; addTab()&#123; if(!this.newValue)&#123; return &#125; this.items.push(this.newValue); this.newValue = &apos;&apos;; this.saveTab(); &#125;, removeTab(n)&#123; this.items.splice(n, 1); this.saveTab(); &#125;, saveTab()&#123; const parsed = JSON.stringify(this.items); localStorage.setItem(&apos;items&apos;, parsed) &#125; &#125;&#125;&lt;/script&gt; 效果如下： 是不是感觉跟普通的标签保存实例差不多但是刷新浏览器，发现数据已存储在浏览器中，而开发者工具来检查客户端存储的情况。 相关笔记： mounted方法是用来加载持久化的数据（存在的话）。 可以通过逻辑判断来决定是否对数据进行存储。 JSON.parse(text)用于将JSON字符串转换为对象，而JSON.stringify(value)用于将js值转换为JSON字符串，要转换的 JavaScript 值（通常为对象或数组）。 localStorage.getItem(key):获取指定key本地存储的值。 localStorage.setItem(key,value)：将value存储到key字段 localStorage.removeItem(key):删除指定key本地存储的值]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue客户端存储]]></title>
    <url>%2F2018%2F12%2F07%2Fvuecc%2F</url>
    <content type="text"><![CDATA[客户端存储关于客户端存储：通过把数据存储在浏览器中，用户不必每次都向服务器请求获取同一个信息。离线时，使用本地存储的数据而不是向远端服务器上请求数据就显得非常有用。 Local Storage 适合存储你希望进行持久化的较小数据集，比如用户偏好设置或表单数据。 注意：存储对象和数组这样更复杂的数据，必须使用 JSON 来对数据进行序列化和反序列化。 太多废话了直接正题 我是一个小案例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;template&gt; &lt;div class=&quot;tab&quot;&gt; &lt;h2&gt;便签&lt;/h2&gt; &lt;p&gt; &lt;input v-model=&quot;newValue&quot; placeholder=&quot;请输入...&quot;&gt; &lt;button @click=&quot;addTab&quot;&gt;AddTab&lt;/button&gt; &lt;/p&gt; &lt;ul&gt; &lt;li v-for=&quot;(value, key) in items&quot;&gt; &lt;span&gt;&#123;&#123; value &#125;&#125;&lt;/span&gt; &lt;button @click=&quot;removeTab(key)&quot;&gt;RemoveTab&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data()&#123; return &#123; items:[], newValue:null &#125; &#125;, mounted()&#123; if(localStorage.getItem(&quot;items&quot;))&#123; try&#123; this.items = JSON.parse(localStorage.getItem(&quot;items&quot;)); &#125; catch(e)&#123; localStorage.removeItem(&apos;items&apos;); &#125; &#125; &#125;, methods:&#123; addTab()&#123; if(!this.newValue)&#123; return &#125; this.items.push(this.newValue); this.newValue = &apos;&apos;; this.saveTab(); &#125;, removeTab(n)&#123; this.items.splice(n, 1); this.saveTab(); &#125;, saveTab()&#123; const parsed = JSON.stringify(this.items); localStorage.setItem(&apos;items&apos;, parsed) &#125; &#125;&#125;&lt;/script&gt; 效果如下： 是不是感觉跟普通的标签保存实例差不多但是刷新浏览器，发现数据已存储在浏览器中，而开发者工具来检查客户端存储的情况。 相关笔记： mounted方法是用来加载持久化的数据（存在的话）。 可以通过逻辑判断来决定是否对数据进行存储。 JSON.parse(text)用于将JSON字符串转换为对象，而JSON.stringify(value)用于将js值转换为JSON字符串，要转换的 JavaScript 值（通常为对象或数组）。 localStorage.getItem(key):获取指定key本地存储的值。 localStorage.setItem(key,value)：将value存储到key字段 localStorage.removeItem(key):删除指定key本地存储的值]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue组件实例]]></title>
    <url>%2F2018%2F09%2F11%2Fvue-module%2F</url>
    <content type="text"><![CDATA[Vue 动画效果过渡模式 相同标签名的元素切换 12345678910111213141516&lt;div id=&quot;demo&quot;&gt; &lt;transition&gt; &lt;button v-bind:key=&quot;isEditing&quot; v-on:click=&quot;isEditing = !isEditing&quot;&gt; &#123;&#123;isEditing ? &apos;save&apos; : &apos;edit&apos;&#125;&#125; &lt;/button&gt; &lt;/transition&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el:&apos;#demo&apos;, data:&#123; isEditing:true &#125;&#125;)&lt;/script&gt; 效果如下： 多个元素的过渡,可重写为绑定了动态属性的单个元素过渡 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;div id=&quot;demo2&quot;&gt; &lt;transition name=&quot;fade&quot; mode=&quot;out-in&quot;&gt; &lt;button v-bind:key=&quot;docState&quot; v-on:click=&quot;rever&quot;&gt; &#123;&#123; buttonMessage &#125;&#125; &lt;/button&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script&gt;new Vue(&#123; el:&apos;#demo2&apos;, data:&#123; docState:0 &#125;, methods: &#123; rever:function()&#123; this.docState += 1; if(this.docState &gt; 2)&#123; this.docState = 0 &#125; &#125; &#125;, computed: &#123; buttonMessage:function()&#123; switch(this.docState) &#123; case 0: return &apos;按钮一&apos;; case 1: return &apos;按钮二&apos;; case 2: return &apos;按钮三&apos;; &#125; &#125; &#125;&#125;)&lt;/script&gt;&lt;style&gt; .fade-enter-active,.fade-leave-active&#123; transition:all 0.3s ease; &#125; .fade-leave-active&#123; opacity:0; transform: translateX(10px); &#125;&lt;/style&gt; 效果如下： 多个组件的过渡，也可以使用动态组件，不需要使用 key 特性。 12345678910111213141516171819202122232425262728293031323334 &lt;div id = &quot;demo&quot;&gt; &lt;input type=&quot;radio&quot; value=&quot;A&quot; id=&quot;a&quot; name=&quot;boy&quot; v-model=&quot;view&quot;&gt; &lt;label for=&quot;a&quot;&gt;A&lt;/label&gt; &lt;input type=&quot;radio&quot; value=&quot;B&quot; id=&quot;b&quot; name=&quot;boy&quot; v-model=&quot;view&quot;&gt; &lt;label for=&quot;a&quot;&gt;B&lt;/label&gt; &lt;p&gt;选择结果：&#123;&#123;view&#125;&#125;&lt;/p&gt; &lt;transition name=&quot;fade&quot; mode=&quot;out-in&quot;&gt; &lt;component v-bind:is=&quot;view&quot;&gt;&lt;/component&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el:&apos;#demo&apos;, data:&#123; view:&apos;A&apos; &#125;, components:&#123; &apos;A&apos;:&#123; template:&apos;&lt;div&gt;模块 A&lt;/div&gt;&apos; &#125;, &apos;B&apos;:&#123; template:&apos;&lt;div&gt;模块 B&lt;/div&gt;&apos; &#125; &#125; &#125;) &lt;/script&gt; &lt;style&gt; .fade-enter-active,.fade-leave-active&#123; transition: opacity 0.3s ease &#125; .fade-enter,.fade-leave-to&#123; opacity:0 &#125;&lt;/style&gt; 效果如下： created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。 渲染函数 &amp; JSX1.渲染多个元素/组件 12345678910111213141516171819&lt;div id=&quot;demo&quot;&gt; &lt;anchored-heading&gt; &lt;/anchored-heading&gt; &lt;/div&gt; &lt;script&gt; Vue.component(&apos;anchored-heading&apos;,&#123; render:function(createElement)&#123; return createElement(&apos;div&apos;, Array.apply(null,&#123;length:5&#125;).map(function()&#123; return createElement(&apos;p&apos;,&apos;hi&apos;) &#125;) ) &#125; &#125;) new Vue(&#123; el:&apos;#demo&apos; &#125;) &lt;/script&gt; 效果如下： template 中使用的 v-if 和 v-for123456789101112131415161718192021222324252627282930&lt;div id=&quot;demo2&quot;&gt; &lt;ul v-if=&quot;items.length&quot;&gt; &lt;li v-for=&quot;item in items&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;p v-else&gt;No items found.&lt;/p&gt; &lt;/div&gt;&lt;script&gt;Vue.component(&apos;menulist&apos;,&#123; props:[&apos;items&apos;], render:function(createElement)&#123; if(this.items.length)&#123; return createElement(&apos;ul&apos;, this.items.map(function(item)&#123; return createElement(&apos;li&apos;,item.name) &#125;)) &#125;else&#123; return createElement(&apos;p&apos;, &apos;No items found.&apos;) &#125; &#125; &#125;) new Vue(&#123; el:&apos;#demo2&apos;, &quot;items.length&quot;:false, data:&#123; items : [ &#123; name: &apos;Foo&apos; &#125;, &#123; name: &apos;Bar&apos; &#125; ] &#125; &#125;)&lt;/script&gt; 效果如下： 过滤器可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和 v-bind 表达式 (后者从 2.1.0+ 开始支持)。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号指示： &lt;!-- 在双花括号中 --&gt; {{ message | capitalize }} &lt;!-- 在 `v-bind` 中 --&gt; &lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt; 例子：输入value值，首个字母大写 12345678910111213141516171819&lt;div id=&quot;demo4&quot;&gt; &lt;input v-model=&quot;message&quot;&gt; &lt;p&gt;&#123;&#123; message | capitalize &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el:&quot;#demo4&quot;, data:&#123; message:&apos;haha&apos; &#125;, filters:&#123; capitalize:function(value)&#123; if(!value) return &apos;&apos; value = value.toString(); return value.charAt(0).toUpperCase() + value.slice(1) &#125; &#125; &#125;) &lt;/script&gt; 效果如下： 表单验证123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;template&gt; &lt;div&gt; &lt;form id=&quot;app&quot; @submit=&quot;checkForm&quot; action=&quot;/something&quot; method=&quot;post&quot; novalidate=&quot;true&quot; &gt;&lt;h3&gt;基础表单验证&lt;/h3&gt; &lt;p v-if=&quot;errors.length&quot; id=&quot;tip&quot;&gt; &lt;b&gt;提交错误：&lt;/b&gt; &lt;ul&gt; &lt;li v-for=&quot;error in errors&quot;&gt;&#123;&#123; error &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;name&quot;&gt;Name&lt;/label&gt; &lt;input id=&quot;name&quot; v-model=&quot;name&quot; type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;age&quot;&gt;age&lt;/label&gt; &lt;input id=&quot;age&quot; v-model=&quot;age&quot; type=&quot;number&quot; name=&quot;age&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;email&quot;&gt;email&lt;/label&gt; &lt;input id=&quot;email&quot; v-model=&quot;email&quot; type=&quot;text&quot; name=&quot;email&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;movie&quot;&gt;movie&lt;/label&gt; &lt;select id=&quot;movie&quot; v-model=&quot;movie&quot; name=&quot;movie&quot;&gt; &lt;option&gt;Star Wars&lt;/option&gt; &lt;option&gt;Vanilla Sky&lt;/option&gt; &lt;option&gt;Atomic Blonde&lt;/option&gt; &lt;/select&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt; &lt;/p&gt; &lt;/form&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data()&#123; return &#123; errors: [], name: null, age: null, email: null, movie: null &#125; &#125;, methods:&#123; checkForm:function(e)&#123; this.errors = []; if(!this.name)&#123; this.errors.push(&apos;请输入姓名&apos;); &#125; if(!this.age)&#123; this.errors.push(&apos;请输入年龄&apos;); &#125; if(!this.email)&#123; this.errors.push(&apos;请输入邮箱&apos;); &#125;else if(!this.validEmail(this.email))&#123; this.errors.push(&apos;请输入正确邮箱&apos;) &#125; if(!this.errors.length)&#123; return true &#125; e.preventDefault(); &#125;, validEmail:function(email)&#123; var re = /^(([^&lt;&gt;()\[\]\\.,;:\s@&quot;]+(\.[^&lt;&gt;()\[\]\\.,;:\s@&quot;]+)*)|(&quot;.+&quot;))@((\[[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]&#123;2,&#125;))$/; return re.test(email); //test() 方法用于检测一个字符串是否匹配某个模式. &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;#tip&#123;overflow: hidden; width: 200px;&#125;#tip ul li&#123; list-style: none;&#125;#tip b&#123;float: left;&#125;#tip ul&#123;float: right; width:50;&#125;#app &#123;margin-top:60px; text-align: left; margin-left: 30px; &#125;#app p&#123;text-align: left; line-height: 30px;&#125;&lt;/style&gt; 效果如下： 自定义滚动事件比如想为网站的滚动事件添加一些行为，尤其是动画。已有的做法很多，但是代码和依赖最少的方式可能就是使用一个自定义指令创建一个钩子，在特定的滚动事件之后作处理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;template&gt; &lt;div id=&quot;scroll&quot;&gt; &lt;h1&gt;滚我&lt;/h1&gt; &lt;div class=&quot;box&quot; v-scroll=&quot;handleScroll&quot;&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. A atque amet harum aut ab veritatis earum porro praesentium ut corporis. Quasi provident dolorem officia iure fugiat, eius mollitia sequi quisquam.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; directives: &#123; scroll: &#123; //指令定义 inserted: function(el, binding) &#123; let f = function(evt) &#123; if (binding.value(evt, el)) &#123; //此时绑定事件的binding.value是一个表达式，此处为方法handleScroll window.removeEventListener(&apos;scroll&apos;, f); &#125; &#125;; window.addEventListener(&apos;scroll&apos;, f); &#125; &#125; &#125;, methods: &#123; handleScroll: function (evt, el) &#123; if (window.scrollY &gt; 50) &#123; el.setAttribute( &apos;style&apos;, &apos;opacity: 1; transform: translate3d(0, -20px, 0)&apos; ) &#125; return window.scrollY &gt; 180 &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt; body&#123;background: #333;&#125; #scroll&#123;color: #fff;height: 2000px; margin-top:180px;&#125; .box&#123; width: 300px; height: 300px; padding: 10px; border:1px solid #ccc; margin:50px auto 0; background:rgba(0, 0, 0, 0.3); opacity: 0;transition: 1s all cubic-bezier(0.39, 0.575, 0.565, 1)&#125; .box p&#123;line-height: 28px;&#125;&lt;/style&gt; 效果如下：注：关于banding.value() 官方文档详解： el: 指令所绑定的元素，可以用来直接操作 DOM 。binding: 一个对象，包含以下属性：name: 指令名，不包括 v- 前缀。value: 指令的绑定值， 例如： v-my-directive=”1 + 1”, value 的值是 2。oldValue: 指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。expression: 绑定值的字符串形式。 例如 v-my-directive=”1 + 1” ， expression 的值是 “1 + 1”。arg: 传给指令的参数。例如 v-my-directive:foo， arg 的值是 “foo”。modifiers: 一个包含修饰符的对象。 例如： v-my-directive.foo.bar, 修饰符对象 modifiers 的值是 { foo: true, bar: true }。vnode: Vue 编译生成的虚拟节点，查阅 VNode API 了解更多详情。oldVnode: 上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 使用axios访问API相关笔记：1、finally()finally方法用于指定不管 Promise 对象最后状态如何2、methods：不调用不会执行。mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。(调用第三方插件可以放在mounted里边)。3、请求会发送到 https://api.coindesk.com/v1/bpi/currentprice.json，创建一个 data 里的属性以最终放置信息，然后将会在 mounted 生命周期钩子中获取数据并赋值过去 API 获取数据时的加载状态 获取价格信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;template&gt; &lt;div id=&quot;demo&quot;&gt; &lt;h1&gt;价格表&lt;/h1&gt; &lt;div v-if=&quot;errored&quot;&gt; &lt;p&gt;很抱歉，我们目前无法检索此信息，请稍后再试&lt;/p&gt; &lt;/div&gt; &lt;div v-else&gt; &lt;div v-if=&quot;loading&quot;&gt;loading...&lt;/div&gt; &lt;div v-else v-for=&quot;currency in info&quot; class=&quot;currency&quot; &gt; &#123;&#123; currency.description &#125;&#125;: &lt;span class=&quot;amount&quot;&gt; &lt;span v-html=&quot;currency.symbol&quot;&gt;&lt;/span&gt; &#123;&#123; currency.rate_float | currencydecimal&#125;&#125; &lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import axios from &apos;axios&apos;export default &#123; data () &#123; return &#123; info: null, loading: true, errored: false &#125; &#125;, filters: &#123; currencydecimal (value) &#123; return value.toFixed(2) &#125; &#125;, mounted () &#123; axios .get(&apos;https://api.coindesk.com/v1/bpi/currentprice.json&apos;) .then(response =&gt; &#123; this.info = response.data.bpi &#125;) .catch(error =&gt; &#123; console.log(error) this.errored = true &#125;) .finally(() =&gt; this.loading = false) &#125;&#125;&lt;/script&gt; 效果如下：]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[关于单文件组件]]></title>
    <url>%2F2018%2F08%2F27%2FSingleFile%2F</url>
    <content type="text"><![CDATA[文件扩展名为 .vue 的 single-file components(单文件组件) 使用 webpack 或 Browserify 等构建工具 标签保存实例： 模板文件： 1.输入框组件 BaseInputText.vue： 123456789101112131415161718192021222324252627282930313233343536&lt;template&gt; &lt;input type=&quot;text&quot; class=&quot;input&quot; :value=&quot;value&quot; v-on=&quot;listeners&quot; &lt;!--这里理解为：父级通过 props 向子级传递数据，子级如果需要修改数据就需要在父级添加监听事件，并在子级中去触发事件修改值。--&gt; &gt;&lt;/template&gt;&lt;script&gt; export default &#123; props:&#123; value:&#123; type:String, default:&apos;&apos; &#125; &#125;, computed:&#123; listeners()&#123; return &#123; //将所有组件侦听器直接传递给输入 ...this.$listeners, //覆盖输入侦听器以使用v-model input: event =&gt; this.$emit(&apos;input&apos;,event.target.value) &#125; &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .input&#123; width: 100%; padding: 8px 10px; border: 1px solid #32485F;; &#125; &lt;/style&gt; 关于v-on=”listeners” 注意：上面，你只需要在组件中声明一个 name 为 value 的 props ，并且通过触发 input 事件传入一个值，就能修改这个 value 。 子组件通过$emit来触发事件，将参数传递出去。 2.标签列表组件TodoListItem.vue： 123456789101112131415161718&lt;template&gt; &lt;li&gt; &#123;&#123; todo.text &#125;&#125; &lt;button @click=&quot;$emit(&apos;remove&apos;,todo.id)&quot;&gt; × &lt;/button&gt; &lt;/li&gt; &lt;/template&gt;&lt;script&gt; export default&#123; props:&#123; todo:&#123; type:Object, required:true &#125; &#125; &#125;&lt;/script&gt; 注意：“$emit(‘remove’,todo.id)”可以理解为：父组件传递数据给子组件，子组件在用户点击按钮时修改父组件数据 3.组件嵌套 TodoList.vue 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;template&gt; &lt;div&gt; &lt;BaseInputText v-model=&quot;newTodoText&quot; placeholder=&quot;New todo&quot; @keydown.enter = &quot;addTodo&quot; /&gt; &lt;ul v-if=&quot;todos.length&quot;&gt; &lt;TodoListItem v-for=&quot;todo in todos&quot; :key = &quot;todo.id&quot; :todo = &quot;todo&quot; @remove = &quot;removeTodo&quot; /&gt; &lt;/ul&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;/template&gt;&lt;script&gt; import BaseInputText from &apos;./BaseInputText.vue&apos; import TodoListItem from &apos;./TodoListItem.vue&apos; let nextTodoId = 1 export default&#123; components:&#123; BaseInputText, TodoListItem &#125;, data()&#123; return &#123; newTodoText : &apos;&apos;, todos:[ &#123; id: nextTodoId++, text: &apos;Learn Vue&apos; &#125;, &#123; id: nextTodoId++, text: &apos;Learn about single-file components&apos; &#125;, &#123; id: nextTodoId++, text: &apos;Fall in love&apos; &#125; ] &#125; &#125;, methods: &#123; addTodo()&#123; const trimmedText = this.newTodoText.trim() if(trimmedText)&#123; this.todos.push( &#123; id:nextTodoId++, text:trimmedText &#125;) newTodoText = &apos;&apos; &#125; &#125;, removeTodo(idToRemove)&#123; this.todos = this.todos.filter(todo =&gt; &#123; return todo.id !== idToRemove &#125;); &#125; &#125; &#125;&lt;/script&gt; 注意：通过addTodo()监听由子组件 vm.$emit触发的事件，通过addTodo()接受从子组件传递过来的数据，通知父组件数据改变了，removeTodo()同样。 4.App.vue是我们的主组件，所有页面都是在App.vue下进行切换的。 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;TodoList/&gt; &lt;!--组件--&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import TodoList from &apos;./components/TodoList.vue&apos; //引入组件export default &#123; name: &apos;app&apos;, components:&#123; TodoList &#125;&#125;&lt;/script&gt;&lt;style&gt;#app &#123; font-family: &apos;Avenir&apos;, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;&lt;/style&gt; 5.在入口文件里面引入vueRouter实例并且挂载到vue实例上 完毕…]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6文档 思维导图笔记]]></title>
    <url>%2F2018%2F07%2F27%2Fes6ryf%2F</url>
    <content type="text"><![CDATA[最近学习了ES6语言。选了几个章节整理了笔记。。。 APIECMAScript 6入门——阮一峰 set和map数据结构 Iterator和for…of循环 Generator 函数 promise对象]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6和ES5语法区别（Reflect对象和Object对象 ）]]></title>
    <url>%2F2018%2F07%2F27%2Freflect%2F</url>
    <content type="text"><![CDATA[概述Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。 现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。 1234567891011121314151617181920//ES5写法try&#123; Object.defineProperty(target,property,attributes); //success&#125; catch(e)&#123; //failure&#125;//ES6写法if(Reflect.defineProperty(target,property,attributes))&#123; //success&#125;else&#123; //failure&#125;//ES5写法Function.prototype.apply.call(Math.floor,undefined,[1.75]) //1//ES6写法Reflect.apply(Math.floor,undefined,[1.75]) //1 Reflect.get(target, name, receiver)Reflect.get方法查找并返回target对象的name属性，如果没有该属性，则返回undefined。 1234567891011var myObject = &#123; foo:1, bar:2, get baz()&#123; return this.foo + this.bar &#125; &#125;Reflect.get(myObject,&apos;foo&apos;) //1Reflect.get(myObject,&apos;bar&apos;) //2Reflect.get(myObject,&apos;baz&apos;) //3 如果name属性部署了读取函数（getter），则读取函数的this绑定receiver。1234567891011121314var myObject = &#123; foo: 1, bar: 2, get baz() &#123; return this.foo + this.bar; &#125;,&#125;;var myReceiverObject = &#123; foo: 4, bar: 4,&#125;;Reflect.get(myObject, &apos;baz&apos;, myReceiverObject) // 8 第一个参数不是对象，Reflect.get方法会报错。12Reflect.get(1, &apos;foo&apos;) // 报错Reflect.get(false, &apos;foo&apos;) // 报错 Reflect.set(target, name, value, receiver)Reflect.set方法设置target对象的name属性等于value值。 1234567891011121314var myObject = &#123; foo:1, set bar(value)&#123; return this.foo = value; &#125;&#125;myObject.foo //1Reflect.set(myObject,&apos;foo&apos;,2);myObject.foo //2Reflect.set(myObject,&apos;bar&apos;,3);myObject.foo //3 如果name属性设置了赋值函数，则赋值函数的this绑定receiver。 1234567891011121314var myObject = &#123; foo: 4, set bar(value) &#123; return this.foo = value; &#125;,&#125;;var myReceiverObject = &#123; foo: 0,&#125;;Reflect.set(myObject, &apos;bar&apos;, 1, myReceiverObject);myObject.foo // 4myReceiverObject.foo // 1 如果第一个参数不是对象，Reflect.set会报错。 12Reflect.set(1, &apos;foo&apos;, &#123;&#125;) // 报错Reflect.set(false, &apos;foo&apos;, &#123;&#125;) // 报错 Reflect.has(obj, name)Reflect.has方法对应name in obj里面的in运算符。 123456789var myObject = &#123; foo:1,&#125;//ES5写法&apos;foo&apos; in myObject //true//ES6写法Reflect.has(myObject,&apos;foo&apos;) Reflect.construct(target,args)Reflect.construct方法等同于new target(…args)，这提供了一种不使用new，来调用构造函数的方法。 123456789function Greeting(name)&#123; this.name = name;&#125;//new的写法const instance = new Greeting(&apos;阿蔡&apos;);//Reflect.construct写法const instance = Reflect.construct(Greeting,[&apos;阿蔡&apos;]); Reflect.getPrototypeOf(obj)Reflect.getPrototypeOf方法用于读取对象的proto属性，对应Object.getPrototypeOf(obj)。 1234567const myObj = new FancyThing();//ES5写法Object.getPrototypeOf(myObj) === FancyThing.prototype;//ES6写法Reflect.getPrototypeOf(myObj) === FancyThing.prototype; Reflect.getPrototypeOf和Object.getPrototypeOf的一个区别是，如果参数不是对象，Object.getPrototypeOf会将这个参数转为对象，然后再运行，而Reflect.getPrototypeOf会报错。 12Object.getPrototypeOf(1) // Number &#123;[[PrimitiveValue]]: 0&#125;Reflect.getPrototypeOf(1) // 报错 Reflect.setPrototypeOf(obj, newProto)Reflect.setPrototypeOf方法用于设置对象的proto属性，返回第一个参数对象，对应Object.setPrototypeOf(obj, newProto)。1234567const myObj = new FancyThing();//ES5写法Object.setPrototypeOf(myObj,OtherThing.prototyype);//ES6写法Reflect.setPrototypeOf(myObj,OtherThing.prototyype); 如果第一个参数不是对象，Object.setPrototypeOf会返回第一个参数本身，而Reflect.setPrototypeOf会报错。 12345Object.setPrototypeOf(1, &#123;&#125;)// 1Reflect.setPrototypeOf(1, &#123;&#125;)// TypeError: Reflect.setPrototypeOf called on non-object 如果第一个参数是undefined或null，Object.setPrototypeOf和Reflect.setPrototypeOf都会报错。 12345Object.setPrototypeOf(null, &#123;&#125;)// TypeError: Object.setPrototypeOf called on null or undefinedReflect.setPrototypeOf(null, &#123;&#125;)// TypeError: Reflect.setPrototypeOf called on non-object Reflect.apply(func, thisArg, args)Reflect.apply方法等同于Function.prototype.apply.call(func, thisArg, args)，用于绑定this对象后执行给定函数。 一般来说，如果要绑定一个函数的this对象，可以这样写fn.apply(obj, args)，但是如果函数定义了自己的apply方法，就只能写成Function.prototype.apply.call(fn, obj, args)，采用Reflect对象可以简化这种操作。 1234567891011const ages = [11, 33, 12, 54, 18, 96];// ES5写法const youngest = Math.min.apply(Math, ages);const oldest = Math.max.apply(Math, ages);const type = Object.prototype.toString.call(youngest);// ES6写法const youngest = Reflect.apply(Math.min, Math, ages);const oldest = Reflect.apply(Math.max, Math, ages);const type = Reflect.apply(Object.prototype.toString, youngest, []); Reflect.defineProperty(target, propertyKey, attributes)Reflect.defineProperty方法基本等同于Object.defineProperty，用来为对象定义属性。 12345678910111213function MyDate() &#123; /*…*/&#125;// ES5写法Object.defineProperty(MyDate, &apos;now&apos;, &#123; value: () =&gt; new Date.now()&#125;);// ES6写法Reflect.defineProperty(MyDate, &apos;now&apos;, &#123; value: () =&gt; new Date.now()&#125;); 如果Reflect.defineProperty的第一个参数不是对象，就会抛出错误，比如Reflect.defineProperty(1, ‘foo’)。 Reflect.getOwnPropertyDescriptor(target, propertyKey)Reflect.getOwnPropertyDescriptor基本等同于Object.getOwnPropertyDescriptor，用于得到指定属性的描述对象。 1234567891011var myObject = &#123;&#125;;Object.defineProperty(myObject, &apos;hidden&apos;, &#123; value: true, enumerable: false,&#125;);// ES5写法var theDescriptor = Object.getOwnPropertyDescriptor(myObject, &apos;hidden&apos;);// ES6写法var theDescriptor = Reflect.getOwnPropertyDescriptor(myObject, &apos;hidden&apos;); Reflect.getOwnPropertyDescriptor和Object.getOwnPropertyDescriptor的一个区别是，如果第一个参数不是对象，Object.getOwnPropertyDescriptor(1, ‘foo’)不报错，返回undefined，而Reflect.getOwnPropertyDescriptor(1, ‘foo’)会抛出错误，表示参数非法。 **Reflect.isExtensible方法对应Object.isExtensible，返回一个布尔值，表示当前对象是否可扩展。** 1234567const myObject = &#123;&#125;;// ES5写法Object.isExtensible(myObject) // true// ES6写法Reflect.isExtensible(myObject) // true 如果参数不是对象，Object.isExtensible会返回false，因为非对象本来就是不可扩展的，而Reflect.isExtensible会报错。 12Object.isExtensible(1) // falseReflect.isExtensible(1) // 报错 Reflect.preventExtensions(target)Reflect.preventExtensions对应Object.preventExtensions方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。 1234567var myObjet = &#123;&#125;;//ES5写法Object.isExtensible(myObject) //true//ES6写法Reflect.preventExtensions(1) //true 如果参数不是对象，Object.isExtensible在 ES5 环境报错，在 ES6 环境返回这个参数，而Reflect.preventExtensions会报错。 12345678// ES5Object.preventExtensions(1) // 报错// ES6Object.preventExtensions(1) // 1// 新写法Reflect.preventExtensions(1) // 报错 Reflect.ownKeys (target)Reflect.ownKeys方法用于返回对象的所有属性，基本等同于Object.getOwnPropertyNames与Object.getOwnPropertySymbols之和。 12345678910111213141516var myObject = &#123; foo:1, bar:2, [Symbol.for(&apos;baz&apos;)]:3, [Symbol.for(&apos;bing&apos;)]:4&#125;;//ES5写法Object.getOwnPropertyNames(myObject) //[&apos;foo&apos;, &apos;bar&apos;]Object.getOwnPropertySymbols(myObject)//[Symbol.for(&apos;baz&apos;), Symbol.for(&apos;bing&apos;)]// ES6写法Reflect.ownKeys(myObject)// [&apos;foo&apos;, &apos;bar&apos;, Symbol.for(&apos;baz&apos;), Symbol.for(&apos;bing&apos;)]]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6和ES5语法区别（常量、作用域、箭头函数）]]></title>
    <url>%2F2018%2F05%2F12%2Fes6%2F</url>
    <content type="text"><![CDATA[1.常量在ES3中，没有常量这一说。在ES5中，通过变量的定义只读，不可修改。在ES6中，用const定义常量也是只读，不可修改。 举个例子,设置圆周率PI的值： 12345//es5写法Object.defineProperty(window,&apos;PI&apos;,&#123; value:3.1415926,//定义属性值 writable:false,//是否只读&#125;) 在控制台看 123//es6写法const PI = 3.1415926;console.log(PI) 在控制台结果 如果赋值PI = 4,那么将会报错 总结：es5和es6的常量在运行时是不一样的，es5中常量赋值不会成功，也不会报错 2.作用域ES5和ES6区别 举个例子： 12345678910111213141516171819202122232425//ES5作用域var callbacks = [];for(var i = 0; i &lt;= 2; i++)&#123; callbacks[i] = function() &#123; return i * 2 &#125;&#125;console.table([ callbacks[0](), callbacks[1](), callbacks[2]() ])//ES6作用域const callbacks2 = [];for(let j = 0; j &lt;= 2; j++)&#123; callbacks2[j] = function()&#123; return j * 2 &#125;&#125;console.table([ callbacks2[0](), callbacks2[1](), callbacks2[2]() ]) 控制台结果： 额。。。值得注意的是，在ES5作用域中返回的结果都会6，var i = 0是全局中的变量， return i * 2 返回的不是一个值，而是一个表达式 ，所以callbacks 内部 function 形成一个闭包，但闭包内并没有声明内部的 i 变量，因此 i 变量从for 循环内声明的全局变量中取得，从全局变量中取得时的 i=3 是最终计算量。 而在ES6中 let申明使每次产生新的作用域 (块级作用域) 也就是把当前的j值保存下来，供内部作用域使用，不再担心闭包的副作用，所以不出现上述情况。 再举个例子，如果我们用块作用域给代码做隔离： 123456789101112131415161718192021222324252627//ES5语法;((function()&#123; var foo = function()&#123; return 1 &#125;; console.log(&quot;函数foo()===1&quot;,foo()===1); ;((function()&#123; var foo = function()&#123; return 2 &#125;; console.log(&quot;函数foo()===2&quot;,foo()===2); &#125;)())&#125;)())//ES6语法&#123; function foo()&#123; return 1 &#125; console.log(&quot;函数foo()===1&quot;,foo()===1); &#123; function foo()&#123; return 2 &#125; console.log(&quot;函数foo()===2&quot;,foo()===2); &#125;&#125; 控制台结果 总结：ES5 中通过立即执行函数来创建块级作用域，ES6中可直接使用花括号来创建块级作用域 题外话：这里关于let和var、const区别： 使用var声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象；使用let声明的变量，其作用域为该语句所在的代码块内，不存在变量提升；使用const声明的是常量，在后面出现的代码中不能再修改该常量的值。 知乎，关于JavaScript中var、let、const区别？ 3.箭头函数ES3、ES5普通函数 ： function a(){}ES6箭头函数： () =&gt; {}; 举个例子，通过map方法将原数组“映射”成对应的新数组： 123456//ES3，ES5写法var a = [1,2,3,4,5];var b = a.map(function(i) &#123; return i + 1&#125;); console.log(a,b); 控制台结果 1234//ES6写法let a = [1,2,3,4,5];let b = a.map(i =&gt; i + 1)console.log(a,b); 控制台结果： 总结：箭头函数和普通函数在再于let的绑定；当函数只有一个参数时，可以省略括号，但函数只返回一个值时，可以省略花括号 然后~这里还要说下关于箭头函数this指向问题。注意：普通函数this指向:是该函数被调用的的对象，箭头函数：定义时this的指向（指向全局window对象） 再举个例子：12345678910111213141516171819202122232425//ES3，ES5function foo()&#123; this.a = &apos;a&apos;; this.b = &apos;b&apos;; this.c = &#123; a: &apos;a+&apos;, b: function() &#123; return this.a &#125; &#125;&#125;console.log(new foo().c.b());//ES6function foo2()&#123; this.a = &apos;a&apos;; this.b = &apos;b&apos;; this.c = &#123; a:&apos;a+&apos;, b:() =&gt; &#123; return this.a &#125; &#125;&#125;console.log(new foo2().c.b()); 控制台效果： 这里可以看到实例化一个foo对象后，调用c对象里面的b方法。在普通函数this指向的是该函数被调用的对象，也就是c对象，所以输出a+。而在ES6箭头函数中，函数体内的this.a是构造函数foo定义的this.a，所以输出a。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack安装（构建ES6的编译环境）]]></title>
    <url>%2F2018%2F05%2F12%2Fwebpack%2F</url>
    <content type="text"><![CDATA[1.在此之前先安装Git，安装node.js 先全局安装 “npm install webpack -g” “npm install webpack-dev-server -g” 2.新建一个文件 例如“es6-webpack”，然后鼠标右键进入Git Bach here; 输入“git clone https://github.com/cucygh/es6-webpack.git”，如果电脑已经配置好了SSH，则在github里选中Use SHH, “git@github.com:cucygh/es6-webpack.git”,这个的话用起来很快。日后不用输入用户名和密码 ，比较方便。然后快车键安装。 安装包地址：https://github.com/cucygh/es6-webpack 3.cd 进入es6-webpack文件，或者直接进入该文件，右键Git Bach here &gt; 执行 npm install 4. 运行 npm start 注：创建文件：]]></content>
      <categories>
        <category>工具/搭建环境</category>
      </categories>
      <tags>
        <tag>工具/环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于PHP服务端代码调试]]></title>
    <url>%2F2018%2F05%2F12%2Fphp-ajax%2F</url>
    <content type="text"><![CDATA[在没有客户端的情况下，就对服务端的一些请求进行一些测试，这是怎么样来做到的呢？我们通过一个工具fiddler工具，这个工具可以监听整个电脑所有发出的 HTTP请求，可以监听它们传入的值，和相应回来的值，当然在这里边它还可以去模拟浏览器向服务器发送请求的过程 1.首先，把demo放在xampp的htdocs文件下,然后运行本地服务器 2.打开fiddler,选择Composer的标签页，选择get选项 ，复制浏览器地址，然后右上角execute执行 这时候是没有任何返回值的，显示参数错误。 3.查询信息 比如查询某员工信息， 比如输入员工编码number=101，根据后端参数定义。 查询结果 4.添加员工信息，选择post选项 一般用post方法来修改表格 注意：用post请求的时候要用到contentType：application/x-www-form-urlencodeed, 告诉服务器是表单格，页面表单数据向服务端传输时的编码方式 application/x-www-form-urlencoded 添加完毕后，右上角execute执行，双击URL链接。显示保存信息成功 至此，后台请求已经测试完毕了。]]></content>
      <categories>
        <category>工具/环境搭建</category>
      </categories>
      <tags>
        <tag>工具/环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6和ES5语法区别（默认参数、对象代理）]]></title>
    <url>%2F2018%2F05%2F12%2Fes62%2F</url>
    <content type="text"><![CDATA[4.默认参数1.es3/es5/es6中如何给默认参数赋值 ？ 举个例子，函数传入x,y,z参数相加，如果y,z不传入值。则默认为2、31234567891011121314151617//ES3、ES5 function foo(x,y,z)&#123; if(y === undefined)&#123; var y = 2; &#125; if(z === undefined)&#123; var z = 3; &#125; return x + y + z&#125;console.log(foo(1));//ES6 function foo2(x,y = 2,z = 3)&#123; return x + y + z &#125; console.log(foo2(1)) 控制台结果： 输出都为6, 如果console.log(foo(1,5))，那么输出为9 结论：ES3、ES5中参数声明默认值在{}中进行，而ES6中可直接在()内声明默认值。 2.es6中如何对必选参数优雅的抛出异常？ 刚刚第一个例子是x必须输入默认参数，如果x不输入呢？ 1234567function checkError()&#123; throw new Error(&apos;出错了&apos;) &#125; function foo(x = checkParameter(), y = 2, z = 3) &#123; return x + y + z &#125; console.log(foo(1)); 这时候后台输入为6。 123456//如果在上面代码加上try &#123; foo() &#125; catch (e) &#123; console.log(e); &#125; finally &#123;&#125; 控制台显示： 报错 3.当默认参数多个时es3/es5/es6如何处理？ 举个例子，函数foo的默认参数相加输出的值： 123456789101112131415161718//ES3,ES5可变参数 function foo()&#123; var a = Array.prototype.slice.call(arguments,0);//调用方法的参数截取出来，转换成一个数组对象 var sum = 0; a.forEach(function(item)&#123; //item参数指数组的每个元素，并将元素传递给回调函数 sum += item * 1 //这里乘以1是为了转化为number &#125;) return sum &#125; console.log(foo(1,2,3));//ES6可变参数 function foo2(...a)&#123; //...a可扩展性运算符 var sum = 0; a.forEach(item =&gt; sum += item * 1); return sum; &#125; console.log(foo2(1,2,3)); 控制台输出结果相同： 总结：当函数有多个参数时，ES6可直接用“…a”来代替，例如用在函数+-×÷这块 4.关于ES3/ES5和ES6合并数组的区别？ 举个例子： 123456789 //ES5合并数组 var array = [1995,&apos;女&apos;,&apos;前端&apos;,true]; var array2 = [&apos;广州&apos;,&apos;阿蔡&apos;].concat(array); console.log(array2); //ES6合并数组var array = [1995,&apos;女&apos;,&apos;前端&apos;,true];var array2 = [&apos;广州&apos;,&apos;阿蔡&apos;,...array];console.log(array2); 控制台结果：输出相同 总结：“…a”可扩展性运算符除了可以代替多个默认参数之外还可以合并数组 5.对象代理什么是对象代理？比如我们封装了一组数据，通过访问代理，对数据访问做限制，而用户访问的是代理层，而不是源数据。这样就进行数据保护。 ES3/ES5 和ES6数据保护区别 12345678910111213141516171819202122232425262728293031323334353637 //ES3,ES5写法 var Person = function()&#123; var data = &#123; name:&apos;阿蔡&apos;, sex:&apos;female&apos;, age:23 &#125; this.get = function(key)&#123; return data[key] &#125; this.set = function(key,value)&#123; if(key !== &apos;sex&apos;)&#123; data[key] = value &#125; &#125; &#125; var person = new Person(); console.table(&#123; name: person.get(&apos;name&apos;), sex:person.get(&apos;sex&apos;), age: person.get(&apos;age&apos;) &#125;)``` 控制台结果![这里写图片描述](es62/5.jpg)现在我们修改name属性：person.set(&apos;name&apos;, &apos;acai&apos;);控制台结果：修改成功![这里写图片描述](es62/6.jpg)如果我们修改sex属性呢？ 修改为男性 person.set(&apos;sex&apos;, &apos;man&apos;);![这里写图片描述](es62/7.jpg)可以看到sex没有变化，属性不可修改。**当然还有一个另一种方法，就是利用ES5的一个特性，defineProperty()方法。用于定义对象新属性或修改原有属性。如：** //ES5写法//ES5 var Person = { name: ‘阿蔡’, age: 23 } Object.defineProperty(Person,’sex’,{ writable:false, value:’female’ }) console.table({ name: Person.name, sex:Person.sex, age: Person.age }) 12345控制台结果跟之前输出结果一样。现在来修改sex属性，控制台报错。不可修改sex属性。因为该属性设置只读。![这里写图片描述](es62/8.jpg) **最后来看下ES6数据保护写法** let Person = { name: ‘阿蔡’, sex: ‘女’, age: 23 } let person = new Proxy(Person,{ //Person为代理的对象 //get为读取操作,参数target为代理对象的数据，key是你要读的哪个属性。 get:function(target, key){ return target[key] }, //set为设置修改操作，value为属性值 set:function(target,key,value){ if(key!==’sex’){ target[key]=value; } } }) console.table({ name:person.name, sex:person.sex, age:person.age });`控制台结果： 注：这里是ES6新特性：Proxy代理器使用new Proxy创建代理器， 第一个参数为一个对象， 第二个参数也为一个对象， 返回被包裹后的代理器， 我们使用基本的get和set写一个demo： 然后我们来修改一下sex属性 person.sex=’男’;修改失败，报错。 总结：通过访问代理，解决变量私有保护，对数据访问做限制，而用户访问的是代理层，而不是源数据。这样就据进行数保护了。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax概念、原理（后续:ES6 Promise对象实现Ajax操作例子）]]></title>
    <url>%2F2018%2F04%2F28%2FAjax-Introduction%2F</url>
    <content type="text"><![CDATA[一本正经的介绍AJAX：Asynchronous JavaScript and XML （异步的 JavaScript 和 XML）Ajax 不是某种编程语言，是一种在无需重新加载整个网页的情况下能够更新部分网页的技术。 1.同步与异步 Ajax三步骤： 运用HTML和CSS实现页面，表达信息； 运用XMLHttpRequest和web服务器进行数据的异步交换； 运用JavaScript操作DOM，实现动态局部刷新；XMLHttpRequest对象：后台和服务器交换数据 打个比方比如填写用户注册表单： 同步：当用户填写完信息之后，全部提交给服务器，等待服务器的回应，是一次性全部的。这就可能造成，提交后发现某处错误 需要重新返回填写表单。 异步：当用户填写完一条信息之后，这条信息会自动向服务器提交，然后服务器响应客户端，在此过程中，用户依然在填写表格的信息，即向服务器请求多次，如果填写错，则页面提醒表单错误，节省了用户的时间，提高了用户的体验。 XMLhttpRequest对象来实现这一功能，也需要javascript来操作DOM实现局部的信息更新。 2. Ajax-XMLHttpRequest对象创建 处理兼容性，代码如下： 12345678var request;if(window.XMLHttpRequest)&#123; // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码 request = new XMLHttpRequest(); &#125;else&#123; // IE6, IE5 浏览器执行代码 request = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; 然后发现一个问题,就是在日常接触中，new出一个ActiveXObject对象括号里的Msxml2.XMLHTTP，还有编辑器默认的是Microsoft.XMLHTTP 这里注意一下 new ActiveXObject(“Msxml2.XMLHTTP“); 和new ActiveXObject(‘Microsoft.XMLHTTP‘); 的区别。 百度了下大概是：Msxml2.XMLHTTP是高版本,受msxml3.dll+支持Microsoft.XMLHTTP是低本,一般是msxml2.6以下版本使用 3 Ajax-HTTP请求 一个完整的【HTTP请求】过程有7个步骤： 1&gt;建立TCP连接（TCP即传输控制协议）2&gt;Web浏览器向Web服务器发送请求命令3&gt;Web浏览器发送请求头信息4&gt;Web服务器应答5&gt;Web服务器发送应答头信息6&gt;Web服务器向浏览器发送数据7&gt;Web服务器关闭TCP连接 HTTP请求一般由4部分组成1.HTTP请求的方法或动作，post或get2.正在请求的URL3.请求头，包含一些客户端环境信息，身份验证信息等4.请求体(请求正文)，包含要发送的一些字符串信息,表单信息等等//请求头和请求体之间有一个空行，表面请求头已经结束 举个例子 ! 【HTTP响应】一般由3部分组成：①一个数字或文字组成的状态码，用来显示请求是成功还是失败②响应头，和请求头一样包含许多有用信息，如服务器类型、日期时间、内容类型和长度等③响应体，即响应正文//响应头和响应体之间有空行 【HTTP状态码】1XX：信息类，表示收到Web浏览器请求，正在进一步处理中2XX:成功，表示用户请求被正确接收3XX:重定向，表示请求没有成功，客户必须采取进一步动作4XX:客户端错误，表示客户端提交的请求有错误，例如：404 NOT Found,意味着请求中所引用的文档不存在5XX:服务器错误，表示服务器不能完成对请求的处理，如：500 ————————————–这是一条分割线——————————————– 这里要说明下GET和POST的区别 get请求用户获取信息，无法修改，一般用来查询，所以不会影响数据本身，但发送的信息是可见的。所以用着发送用户名和密码提交的不安全的。 所有的变量名和值都显示在UL列表里，也是说get请求用ul li列表来传递参数，所以get请求发送的字符也有了限制。 post请求是向服务器发送一些信息，一般用来修改服务器信息，发送的信息是不可见的，相对来说安全性高一点。 总之 ，get一般用来做查询数据，post用来做发送表单数据，增添 删除 修改… 4 Ajax-XMLHttpRequest发送请求 XMLHttpRequest发送请求有两个方法： open(method,url,async) //准备请求 method：规定HTTP发送请求的方式是get还是post,不区分大小写，一般来说用大写url：请求地址(相对地址或绝对地址)async:同步/异步(false/true)，默认是异步也就是true，可以不用填写 send(string) //发送请求 发送到服务器（该参数可以填或者不填—–get方法不填或填null，post:一般要填） 如果需要像 HTML 表单那样 POST 数据，请使用 setRequestHeader() 来添加 HTTP 头。然后在 send() 方法中规定您希望发送的数据： setRequestHeader(header,value) //向请求添加 HTTP 头。 header: 规定头的名称value: 规定头的值 图中 Content-type”告诉服务器是表单格，页面表单数据向服务端传输时的编码方式 application/x-www-form-urlencoded 5.Ajax-XMLHttpRequest取得响应数据 监听readyState属性，请求过程readyState属性的变化代表服务器响应的变化0：请求未初始化，open还没有调用1：服务器连接已建立，open已经调用了2：请求已接收，也就是接收到头信息了3：请求处理中，也就是接收到了响应主体4：请求已完成，且响应已就绪，也就是响应完成了 建立异步请求的过程4个步骤： 12345678var request = new XMLHttpRequest(); //创建一个XMLHttpRequest对象request.open(&apos;GET&apos;,url,true); //调用open方法，准备请求request.sell(); //调用sell方法，发送请求传递一些参数，get请求可忽略request.onreadystatechange = function()&#123; //过程进行监听,响应请求成功时，发生事件 if(request.readState === 400 &amp;&amp; request.status == 2)&#123; request.responseText; &#125;&#125; ##后续：ES6 Promise对象实现异步加载 最近学习深入浅出ES6中Promise一章里提到关于Promise对象实现Ajax操作例子。补充一下1234567891011121314151617181920212223242526272829303132 var getJSON = function(url)&#123; var promise = new Promise(function(resolve,reject)&#123; var request = new XMLHttpRequest(); //创建一个XMLHttpRequest对象 request.open(&apos;GET&apos;,url); //准备请求 request.onreadystatechange = handler; //过程进行监听,响应请求成功时，发生事件 request.responseType = &apos;json&apos;; //请求的数据类型 request.setRequestHeader(&apos;Accept&apos;,&apos;application/json&apos;);//向请求添加 HTTP 头。 request.send();//发送请求,get请求不填或填null function handler()&#123; if(this.readyState !== 4)&#123; //如果请求失败,直接中断 return; &#125; if(this.status === 200)&#123; //如果状态码请求被正确接收 resolve(this.response); //调用resolve回调函数 &#125;else&#123; //否则抛出错误 reject(new Error(this.statusText)); &#125; &#125;; &#125;); return promise; //返回结果 &#125;; getJSON(&quot;/posts.json&quot;).then(function(json)&#123; console.log(&apos;contents:&apos; + json); &#125;,function(error)&#123; console.error(&apos;出错了&apos;, error); &#125;) ES6Promise对象章节 如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js深入浅出(数组、函数、作用域、闭包)]]></title>
    <url>%2F2018%2F04%2F06%2FClosure%2F</url>
    <content type="text"><![CDATA[数组1创建数组var arr = [“a”,”b”,”c”]或var arr = new Array();arr[0] = a;arr[1] = b;arr[2] = c 2.数组的删增 3.数组的迭代 4.二维数组的遍历 123456var arrayStr=[[1,2,3],[4,5,6],[7,8,9]];for(var i=0;i&lt;arrayStr.length;i++)&#123; for(var j=0;j&lt;arrayStr[i].length;j++)&#123; console.log(&quot;第&quot;+i+&quot;行 第&quot;+j+&quot;列 的值为:&quot;+arrayStr[i][j]); &#125; &#125; 5.稀疏数组1.稀疏数组，下标不是从0开始，length&gt;实际数组元素个数 2.可以直接给一个空数组，通过赋值的方式，指定某个下标值为多少，如果只是指定下标没有赋值，那么数组依然是空的，用in判断指定下标值 in 数组，返回是false，一旦赋值了，哪怕是undefined，null或是’’,数组就不再是空的了，用指定下标值 in 数组，返回是true 6.数组方法 join(),把数组转换为字符串，拼一些参数reverse(),逆序，原数组是会被修改的sort()，排序，原数组是会被修改的concat(),合并数组，原数组不会被修改slice()，返回数组的一个偏度splice(),数组的拼接Array.prototype.every &amp; some 数组判断every 验证某个数组是否每一个元素都符合某个条件some 验证某个数组是否存在一个元素符合某个条件 Array.prototype.join将数组转为字符串 例如： 123456789var arr = [1, 2, 3];arr.join(); // &quot;1,2,3&quot;arr.join(&quot;_&quot;); // &quot;1_2_3&quot;function repeatString(str, n) &#123; return new Array(n + 1).join(str);&#125;repeatString(&quot;a&quot;, 3); // &quot;aaa&quot;repeatString(&quot;Hi&quot;, 5); // &quot;HiHiHiHiHi&quot; Array.prototype.reverse将数组逆序 例如：123var arr = [1, 2, 3];arr.reverse(); // [3, 2, 1]arr; // [3, 2, 1]注：原数组被修改 Array.prototype.sort数组排序 123456789var arr = [&quot;a&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;];arr.sort(); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]arr = [13, 24, 51, 3];arr.sort(); // [13, 24, 3, 51]arr; // [13, 24, 3, 51]原数组被修改arr.sort(function(a, b) &#123; return a - b;&#125;); // [3, 13, 24, 51] 1234567891011arr = [&#123;age : 25&#125;, &#123;age : 39&#125;, &#123;age : 99&#125;];arr.sort(function(a, b) &#123; return a.age - b.age;&#125;);arr.forEach(function(item) &#123; console.log(&apos;age&apos;, item.age);&#125;);// result:// age 25// age 39// age 99 Array.prototype.concat数组合并 例如： 12345var arr = [1, 2, 3];arr.concat(4, 5); // [1, 2, 3, 4, 5]arr; // [1, 2, 3]arr.concat([10, 11], 13); // [1, 2, 3, 10, 11, 13] arr.concat([1, [2, 3]]); // [1, 2, 3, 1, [2, 3]] Array.prototype.forEach数组遍历，ES5特性，兼容IE9及以上的浏览器。 例如：123456789var arr = [1, 2, 3, 4, 5];arr.forEach(function(x, index, a)&#123; console.log(x + &apos;|&apos; + index + &apos;|&apos; + (a === arr));&#125;);// 1|0|true// 2|1|true// 3|2|true// 4|3|true// 5|4|true Array.prototype.map数组映射 12345var arr = [1, 2, 3];arr.map(function(x) &#123; return x + 10;&#125;); // [11, 12, 13]arr; // [1, 2, 3] 数组未被修改 Array.prototype.filter 数组过滤 例如：查找索引值能被3整除，或数组元素大于8的元素12345var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];arr.filter(function(x, index) &#123; return index % 3 === 0 || x &gt;= 8;&#125;); // returns [1, 4, 7, 8, 9, 10]arr; // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 原数组未被修改 Array.prototype.every &amp; some数组判断 every 验证某个数组是否每一个元素都符合某个条件 例如：判断数组元素小于10/小于312345678var arr = [1, 2, 3, 4, 5];arr.every(function(x) &#123; return x &lt; 10;&#125;); // truearr.every(function(x) &#123; return x &lt; 3;&#125;); // false some 验证某个数组是否存在一个元素符合某个条件 例如：判断是否存在一个等于3的数组元素/等于100的数组元素12345678var arr = [1, 2, 3, 4, 5];arr.some(function(x) &#123; return x === 3;&#125;); // truearr.some(function(x) &#123; return x === 100;&#125;); // false Array.prototype.reduce&amp;reduceRight两两逻辑操作 - 原數組未被修改 例如：比较最大值 1234567max = arr.reduceRight(function(x, y) &#123; console.log(x + &quot;|&quot; + y); return x &gt; y ? x : y;&#125;);// 6|9// 9|3max; // 9 reduce接收一个有两个参数的函数与一个可选参数可选参数提供时作为第一个x的值被函数使用reduceRight功能与reduce相同，区别是从右往左遍历 Array.prototype.indexOf&amp;lastIndexOf数组检索，indexOf从左向右，lastIndexOf相反 实例：arr.indexOf(val[, fromIndex]) 参数说明：从索引开始，查找值；缺省为0，负数表示倒数。 例如： 123456789var arr = [1, 2, 3, 2, 1];arr.indexOf(2); // 1arr.indexOf(99); // -1arr.indexOf(1, 1); // 4arr.indexOf(1, -3); // 4arr.indexOf(2, -1); // -1arr.lastIndexOf(2); // 3arr.lastIndexOf(2, -2); // 3arr.lastIndexOf(2, -3); // 1 Array.isArray判断是否为数组 Array.isArray([]); // true 其他判断方法 12345678910111213141516171819202122232425262728293031323334[] instanceof Array; // true(&#123;&#125;).toString.apply([]) === &apos;[object Array]&apos;; // true[].constructor === Array; // true----------函数和作用域===========**1.函数申明与表达式**1、函数声明：function name(param*)&#123;statement*&#125;2、函数表达式：var name = function(param)&#123;statement&#125;;3、函数实例化（不推荐）：var name = new Function(&quot;param&quot;,&quot;statement&quot;&#125;;**2.this指向：**1、直接调用函数（function()）：this指向全局对象。![这里写图片描述](https://img-blog.csdn.net/20180407193519109?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MDM2MjU1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)2、方法调用模式（object.function()）：this指向调用者object。![这里写图片描述](https://img-blog.csdn.net/20180407193536765?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MDM2MjU1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)3、构造函数调用模式（obj = new function()）：this指向被构造者obj。![这里写图片描述](https://img-blog.csdn.net/20180407193546899?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MDM2MjU1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)4、apply/call/bind方法：this指向方法的第一个参数。call与apply的区别：call传参是扁平的，apply传参是把参数作为一个数组,**obj.call(thisObj, arg1, arg2, ...);****obj.apply(thisObj, [arg1, arg2, ...]);**两者作用一致，都是把obj(即this)绑定到thisObj，这时候thisObj具备了obj的属性和方法。或者说thisObj『继承』了obj的属性和方法。绑定后会立即执行函数。例如： function add(j, k){ return j+k;} function sub(j, k){ return j-k;} 我们在控制台运行： add(5,3); //8add.call(sub, 5, 3); //8add.apply(sub, [5, 3]); //8 sub(5, 3); //2sub.call(add, 5, 3); //2sub.apply(add, [5, 3]); //2 `bind的使用 obj.bind(thisObj, arg1, arg2, …); 把obj绑定到thisObj，这时候thisObj具备了obj的属性和方法。与call和apply不同的是，bind绑定后不会立即执行。 同样是add()和sub()： add.bind(sub, 5, 3); //不再返回8add.bind(sub, 5, 3)(); //8 如果bind的第一个参数是null或者undefined，等于将this绑定到全局对象。bind连续使用，可以依次绑定不同的函数。 5、严格模式下，this不允许指向全局对象，此时this值为undefined。 闭包和作用域1.什么是闭包在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数” 注意：!function(){}()+function(){}();function(){}(),”;”可以避免其之前的脚本最后缺少分号造成的某些浏览器不兼容问题等都是跟(function(){})();是一个意思，都是告诉浏览器自动运行这个匿名函数的，因为!+()这些符号的运算符是最高的，所以会先运行它们后面的函数。 2.作用域 作用域有三种：全局、函数、eval（eval函数是强大的数码转换引擎,字符串经eval转换后得到一个javascript对象,） 作用域链，可以访问到外部的局部变量 JS中没有块级作用域的概念Function的方法来创建函数，函数里面访问不到当前作用域的变量，可以访问到全局作用域的变量例如：for(var i =1;i&lt;3;i++){var b = 5;}这样的写法i 和 b 都是全局的变量 Function的方法来创建函数，函数里面访问不到当前作用域的变量，可以访问到全局作用域的变量 例如： OOP1.概念与继承 Object.create(parent)：三件事: 1. 创建一个对象 2. 继承指定父对象 3. 为新对象扩展新属性 何时使用create: 希望在创建对象时就提前指定继承的父对象，并同时扩展新属性时。 :]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js深入浅出(数据、表达式运算符、语句、对象篇)]]></title>
    <url>%2F2018%2F03%2F31%2FjsArray%2F</url>
    <content type="text"><![CDATA[数据类型2.js隐式转换 关于+- 例如： 123var x = 10 + 5 ; //15var x = &quot;10&quot; + 5; //105var x = &quot;10&quot; - 5 //5 加号可以是加法运算 也可以是字符串拼接，减号则直接是减法运算 变量num转换为数字：num - 0变量num转换为字符串：num + “” == 等于===严格等于（类型必须相同） 1234null === nullundefined === undefinedNaN ≠≠≠ NaNobject ≠≠≠ object //对象比较的是对象的引用 不是具体的对象 3.js包装对象 包装对象：就是将基本类型（number、string、boolean）包装成对象类型。 举个栗子~~~ 假如str是一个字符串类型，不是对象类型。它的属性赋值并不会被保存。所以str.t 值为undefined。只有对象类型的属性赋值会被保存。 1234var str = &apos;string&apos;alert(str.length) // 6str.t = 10 alert(str.t)// undefined 当把一个基础数据类型尝试用对象的方法, 添加属性的时候, js会尝试先把基础类型转化成对应的基础类型包装对象, 但是当完成这个访问以后 , 这个临时的包装对象就会立即被销毁, 所以str.t的值是undefined 4.js类型检测 typeof 适合基础类型和函数类型的检测 , 不适合其他对象类型的检测 例如：123456789alert(typeof 123) //输出数字类型 numberalert(typeof &quot;str&quot;) //输出字符串类型 stringalert(typeof true) //输出布尔类型 booleanalert(typeof undefined) //输出undefined类型 undefinedalert(typeof new Object()) //输出对象类型 objectalert(typeof [1,2]) //数组 输出对象类型 objectalert(typeof function()&#123;&#125;) //函数对象 输出function类型alert(typeof NaN) //输出numberalert(typeof null) //由于历史原因，输出对象类型 object，而不是 null类型 instanceof用来区分引用类型和基本数据型，适用于检测原生对象obj instanceof Object： 左边的操作对象obj的原型链上是否有右边的构造函数的prototype属性例如： 123456function Student()&#123;&#125;function People()&#123;&#125;Student.prototype=Person() //Student的原型指向person（）对象的原型var one=Student();one instanceof Student//one的原型指向Student返回trueone instanceof Person//one的原型先指向Student的原型，发现不对，原型链上移，指向Person的原型，返回true Object.prototype.toString 判断对象数组、函数 例如：12alert(Object.prototype.toString.apply([])) //输出[object Array]alert(Object.prototype.toString.apply(function()&#123;&#125;)) //输出[object Function] constructorduck type 表达式和运算符1.js表达式 1.初始化表达式 1)原始表达式 常量，直接量 eg:3.14 “test”2.关键字 eg: null this true3.变量 i,j k2)复合表达式 eg: 21*3 [1,2] -&gt; new Array[1,2][1,,4] -&gt; [1,undefined,undefined,4]{x:1,y:2} -&gt; var o = new Object();o.x=1;o.y=2 2.函数表达式 var fe =function(){};(function(){ console.log(‘hello world’);})(); 3.属性访问表达式 var o ={x:1};o.x o[‘x’] 4.调用表达式 func() 5.对象创建表达式 new Func(1,2)new Obiect() 语句1.函数 函数声明：function foo(){+}函数表达式：var foo = function(){+}构造函数：var foo = new Function(‘‘*,’‘); 注：函数申明可以预先处理。而函数表达式不能 2.语句 for…in语句for-in是为普通对象设计的，你可以遍历得到字符串类型的键，因此不适用于数组遍历。for-in遍历方式的循环计数器是字符串类型，遍历对象时为对象属性/方法名，遍历数组时为数组元素下标索引，与普通的for循环不同，for-in会将继承的属性/方法列出。 注意：1顺序不确定（依赖于引擎的实现）2.enumerable标签为false时不会出现3.for in对象属性时受原型链影响 switch语句 12345678910111213var val = 2switch(val)&#123;case 1: console.log(1); break;case 2: console.log(2); break;default: console.log(0); break;&#125; //输出2 循环语句 1234567891011121314while(isTrue)&#123; //do sth&#125;----------do&#123; //do sth&#125;while(isTrue)----------for(var i = 0; i &lt; len; i++)&#123;&#125; 3.JS的严格模式定义和优点：严格模式是一种特殊的执行模式，它修复了部分语言上的不足（禁用with），提供了更强的错误检查（重复属性，删除delete不可配置的属性等），并增强了安全性（在eval中使用独立作用域等）；模式的使用：（1）function func(){‘use strict’;}好处：向上兼容（2）’use strict’; function func(){}指定整个js内的代码都是在严格模式下与普通模式的区别：在严格模式下，①不允许使用with；②不允许未声明的变量被赋值③arguments变为参数的静态副本，不管参数传与不传，对arguments无影响，但是对象的属性除外；④delete参数，函数名报错⑤delete不可配置的属性报错⑥对象字面量重复属性名报错⑦禁止八进制字面量⑧eval，arguments变为关键字，不能作为变量、函数名⑨eval变为独立作用域，其它地方不可以拿到eval的值； 对象1.对象概括对象中包含一系列属性，这些属性是无序的，每个属性都是一个字符串key和对应的value。 12345678var obj = &#123;x:1,y:2&#125;;obj.x;//1obj.y//2//或var obj = &#123;&#125;obj[1] = 1;obj[&apos;1&apos;] = 2;obj//Object&#123;1,2&#125; 2.对象结构 3.对象属性读取对象属性： 属性异常 删除属性 检测属性 枚举属性 属性异常 *删除属性var定义的全局变量和局部变量，不可以delete掉，reutrn false。不使用var 则可以删除掉；eval(“var ss = ‘aaa’;”);eval出来的变量是可以delete掉的。（直接或者在函数作用域里面都可以！） 检测属性 cat.hasOwnProperty(“lets”)； //true， hasOwnProperty()表示在对象上查找cat.hasOwnProperty(“toString”) ; //false， 对象上没有toString，原型上才有cat.propertyIsEnumerable(“lets”)； //true，可枚举的属性cat.propertyIsEnumerable(“toString”)； //false，不可枚举的属性 对象是否拥有某个属性，判断的方法有很多，常用的方法就是object.hasOwnProperty(‘×××’)，这个方法是不包括对象原型链上的方法的。 举个例子：12345var obj = &#123; name:&apos;fei&apos;&#125; console.log(obj.hasOwnProperty(&apos;name&apos;))//true console.log(obj.hasOwnProperty(&apos;toString&apos;))//false 在这个例子中，obj对象存在的name属性的时候，调用这个方法才是返回true，我们知道其实每个对象实例的原型链上存在toString方法，在这里打印false，说明这个方法只是表明实例对象的属性，不包括原型链上的属性。 下面我们再来看看in的使用，例子如下： 1234var obj = &#123; name:&apos;fei&apos;&#125; console.log(&apos;toString&apos; in obj)//true 我们可以看到，其实在这个例子中，我只是给了对象一个属性name，并没有其他的属性，然后我执行’tiString’ in obj，可以看出控制动态打印出来的是true，原因就是对象的原型链上存在toString方法，所以in操作不管是不是原型链上，只要存在这个属性，返回的就是true。 接着我们再看for in。在使用for in 循环的时候，其实返回的是能通过对象访问的，可枚举的，包括实例中的，也包括原型中的，例子如下 1234567var obj = &#123; name:&apos;fei&apos;, age:20, friend:[&quot;fei&quot;,&quot;jun&quot;,&quot;zhu&quot;]&#125;for( var i in obj)&#123; console.log(i)//会打印三次，name，age，friend 为什么上面没有打印原型中的属性呢，因为原型中的属性都默认设置了不可枚举（enumerated）；我们将例子改成下面这样： 12345678910111213var obj = &#123; name:&apos;fei&apos;, age:20, friend:[&quot;fei&quot;,&quot;jun&quot;,&quot;zhu&quot;]&#125; Object.defineProperty(obj, &apos;like&apos;, &#123;//使用Object.defineProperty()方法可以设置你设置属性的特性 enumerable:false,//设置不可枚举 value:&apos;basketball&apos;//值为basketball &#125;)console.log(obj)//Object &#123;name: &quot;fei&quot;, age: 20, friend: Array[3], like: &quot;basketball&quot;&#125; for(var i in obj)&#123; console.log(i)//依旧打印三个name,age,friend 从这个例子中可以看出，在给属性设置为不可枚举的时候，是不会出现在for in循环中的，这也造成IE低版本出现bug，就是不可枚举的属性不会出现在for in中，如果你从新定义了一个属性和原型的属性相同，那么这个属性也不会出现在for in中，现在的浏览器不会出现， 例子如下： 12345678910var obj = &#123; toString:function()&#123; return &quot;666&quot; &#125;&#125; for(var i in obj)&#123; if(i==&quot;toString&quot;)&#123; console.log(&apos;我出现了&apos;) //在低版本的IE中不显示 &#125;&#125; 4.要取得所有可枚举的对象，可以使用ECMAscript5的方法Object.keys(),接受一个对象为参数，返回所有可枚举的属性的字符串数组： 123456789101112function People()&#123; &#125;People.prototype.say = function()&#123; console.log(&apos;say&apos;)&#125;People.prototype.name = &quot;feifei&quot;; var people = new People()people.age = 12; console.log(Object.keys(people))//[&apos;age&apos;] Object.keys() 方法会返回一个由一个给定对象的自身可枚举属性组成的数组 这个方法并不会包含原型链中的属性，只是实例中的可枚举的属性。 获取实例中所有属性，无论是否可枚举，利用Object.getOwnPropertyNames(),以对象为参数，返回熟悉的数组。例子： 12345678910111213141516function People()&#123; &#125;People.prototype.say = function()&#123; console.log(&apos;say&apos;)&#125;People.prototype.name = &quot;feifei&quot;; var people = new People()people.age = 12;Object.defineProperty(people, &apos;like&apos;, &#123;//使用Object.defineProperty()方法可以设置你设置属性的特性 enumerable:false,//设置不可枚举 value:&apos;basketball&apos;//值为basketball&#125;)console.log(people)//People &#123;age: 12, like: &quot;basketball&quot;&#125;console.log(Object.getOwnPropertyNames(people))//[&quot;age&quot;, &quot;like&quot;] 这个方法仅仅是返回实例中所有的属性，无论是不是可枚举的，不包括原型里面的属性。 判断属性是否存在的方法 最后：比如： var obj={x:function(){alert(“happy”);}} obj.x //输出function(){alert(“happy”);} obj.x() //弹出alert警告框：happy 属性带上括号，就是调用了它的函数，直接输出函数的结果值。而属性不带括号，输出的就是完整的函数代码，不执行函数。 4.属性读写get和set方法，能够直接操作对象属性实现读写 直接在对象内设置 12345678910111213var obj1 = &#123; name: &apos;shaanxi&apos;, get nameGet() &#123; return this.name + &apos;a&apos;; &#125;, set nameSet(name) &#123; this.name = name; &#125; &#125;; console.info(obj1.nameGet); //shaanxia obj1.nameSet = &apos;set by set keywords&apos;; console.info(obj1.nameGet); //set by set keywordsa 使用原型方法进行设置 12345678910111213141516171819var obj3 = &#123; name: &quot;shaanxi&quot; &#125;; Object.defineProperties(obj3, &#123; nameGet: &#123; value: function() &#123; return this.name; &#125; &#125;, nameSet: &#123; value: function(name) &#123; this.name = name; &#125; &#125; &#125;); console.info(obj3.nameGet()); //shaanxi obj3.nameSet(&apos;set by Object.defineProperty&apos;); console.info(obj3.nameGet()); //set by Object.defineProperty 5.查找属性标签 Object.getOwnPropertyDescriptor(o,name)方法用于查询一个属性的描述符，并以对象的形式返回 例如： 12345var obj = &#123;a:1&#125;;//Object &#123;value: 1, writable: true, enumerable: true, configurable: true&#125;console.log(Object.getOwnPropertyDescriptor(obj,&apos;a&apos;));//undefinedconsole.log(Object.getOwnPropertyDescriptor(obj,&apos;b&apos;)); 查询obj.a属性时，可配置性、可枚举性、可写性都是默认的true，而value是a的属性值1查询obj.b属性时，因为obj.b属性不存在，该方法返回undefined 创建属性标签的方法： defineProperty(参数1-对象，参数2-属性名，参数3-具体每个属性的值) 创建多个属性标签的方法： defineProperties(参数1-对象，参数2-每个属性都是对象) 访问所有属性标签的方法： getOwnPropertyDescriptor(对象，属性名) 属性里可以添加get/set方法 总结 value: 属性值writable: 该属性是否可写，可改变enumerable：该属性是否可被枚举，就是可在for in中出现configurable： 该属性的标签是否可改变，是否可用delete将该属性删除。用defineProperty定义属性时，默认configurable为true，如果设置为false后，该属性不管是什么方式都无法更改。 6.对象标签extensible标签isExtensible(obj)可扩展、preventExtensions(obj)阻止扩展（没有改变属性标签的值）seal(obj)方法在preventExtensions基础上阻止扩展，区别在于configurable为falseObject.isSealed(obj); //true 判断对象obj是否被隐藏freeze()方法，比seal()强度更高，更严格。Object.isFrozen(obj); //true 判断对象是否被冻结]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js内置对象方法]]></title>
    <url>%2F2018%2F03%2F23%2FjsObject%2F</url>
    <content type="text"><![CDATA[String 字符串对象1. toUpperCase() 方法 字符串小写字母转换为大写2. toLowerCase()方法， 字符串所有大写字母都变成小写的字符串 例如：12var mystr=&quot;Hello world!&quot;;var mynum=mystr.toUpperCase(); 以上代码执行后，mynum 的值是：HELLO WORLD!` 3.charAt() 方法可返回指定位置的字符。返回的字符是长度为 1 的字符串。 语法: stringObject.charAt(index) 注意： 1.字符串中第一个字符的下标是 0。最后一个字符的下标为字符串长度减一（string.length-1）。2.如果参数 index 不在 0 与 string.length-1 之间，该方法将返回一个空字符串。 例如： 1234&lt;script type=&quot;text/javascript&quot;&gt; var mystr=&quot;I love JavaScript!&quot; document.write(mystr.charAt(2));&lt;/script&gt; 以上代码的运行结果：l 4.indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。 语法 stringObject.indexOf(substring, startpos) substring：字符串 / startpos：索引值 例如：检索第二个字符ｏ出现的位置。 1234&lt;script type=&quot;text/javascript&quot;&gt; var mystr=&quot;Hello World!&quot; document.write(mystr.indexOf(&apos;o&apos;,mystr.indexOf(&apos;o&apos;)+1));&lt;/script&gt; 以上代码的运行结果：7说明：1.该方法将从头到尾地检索字符串 stringObject，看它是否含有子串 substring。2.可选参数，从stringObject的startpos位置开始查找substring，如果没有此参数将从stringObject的开始位置查找。3.如果找到一个 substring，则返回 substring 的第一次出现的位置。stringObject 中的字符位置是从 0 开始的。 注意：1.indexOf() 方法区分大小写。 5.split()split() 方法将字符串分割为字符串数组，并返回此数组。 语法： stringObject.split(separator,limit) 例如： 1234var mystr = &quot;www.hicai.com&quot;;document.write(mystr.split(&quot;.&quot;)+&quot;&lt;br&gt;&quot;);document.write(mystr.split(&quot;.&quot;, 2)+&quot;&lt;br&gt;&quot;);document.write(mystr.split(&quot;&quot;)+&quot;&lt;br&gt;&quot;); 以上代码的运行结果：www,hicai,comwww,hicaiw,w,w,.,h,i,c,a,i,.,c,o,m 注意：如果把空字符串 (“”) 用作 separator，那么 stringObject 中的每个字符之间都会被分割。 6.substring()用于提取字符串中介于两个指定下标之间的字符。 语法: stringObject.substring(startPos,stopPos) startPos：必需。一个非负整数，开始位置。stopPos：可选。一个非负整数，结束位置。如果没填，那么返回的子串会一直到字符串结束的结尾 例如： 123var mystr=&quot;Hello World!&quot;document.write(mystr.substring(5) + &quot;&lt;br /&gt;&quot;);document.write(mystr.substring(0,5)); 以上代码的运行结果：World!Hello substr()从字符串中提取从 startPos位置开始的指定数目的字符串。 语法 stringObject.substr(startPos,length) startPos：必填，提取子串的起始位置，必须是数值。length：可选，提取子串的长度，如果忽略，则从起始位置到结束位置的字符长度 例如： 12345&lt;script type=&quot;text/javascript&quot;&gt; var mystr=&quot;I love JavaScript!&quot;; document.write(mystr.substr(7)); document.write(mystr.substr(2,4));&lt;/script&gt; 以上代码的运行结果：JavaScript!love ceil()可对一个数进行向上取整。 语法 Math.ceil(x) x：:必填。一个数值 注意：返回的是大于或等于x，并且与 x 最接近的整数。 例如 12345678&lt;script type=&quot;text/javascript&quot;&gt; document.write(Math.ceil(0.8) + &quot;&lt;br /&gt;&quot;) document.write(Math.ceil(6.3) + &quot;&lt;br /&gt;&quot;) document.write(Math.ceil(5) + &quot;&lt;br /&gt;&quot;) document.write(Math.ceil(3.5) + &quot;&lt;br /&gt;&quot;) document.write(Math.ceil(-5.1) + &quot;&lt;br /&gt;&quot;) document.write(Math.ceil(-5.9))&lt;/script&gt; 以上代码的运行结果：1754-5-5 floor()可对一个数进行向下取整。 语法 Math.floor(x) x:必填，必须是一个数值 注意：返回的是小于或等于x，并且与 x 最接近的整数。 例如： 123456&lt;script type=&quot;text/javascript&quot;&gt;document.write(Math.floor(3.3)+&apos;&lt;br/&gt;&apos;);document.write(Math.floor(0.1)+&apos;&lt;br/&gt;&apos;);document.write(Math.floor(-9.9)+&apos;&lt;br/&gt;&apos;);document.write(Math.floor(8.9)+&apos;&lt;br/&gt;&apos;);&lt;/script&gt; 以上代码的运行结果：30-108 round()round() 方法可把一个数字四舍五入为最接近的整数。 语法: Math.round(x) x：必填，必须是数字 例如： 123456&lt;script type=&quot;text/javascript&quot;&gt;document.write(Math.round(3.3) + &apos;&lt;br/&gt;&apos;);document.write(Math.round(-0.1) + &apos;&lt;br/&gt;&apos;);document.write(Math.round(-9.9) + &apos;&lt;br/&gt;&apos;);document.write(Math.round(8.9) + &apos;&lt;br/&gt;&apos;);&lt;/script&gt; 以上代码的运行结果：30-109 注意：1. 返回与 x 最接近的整数。2. 对于 0.5，该方法将进行上舍入。(5.5 将舍入为 6)3. 如果 x 与两侧整数同等接近，则结果接近 +∞方向的数字值 。(如 -5.5 将舍入为 -5; -5.52 将舍入为 -6) random()random() 方法可返回介于 0 ~ 1（大于或等于 0 但小于 1 )之间的一个随机数。 语法： Math.random(); 注意：返回一个大于或等于 0 但小于 1 的符号为正的数字值。 我们取得介于 0 到 1 之间的一个随机数，代码如下： 123&lt;script type=&quot;text/javascript&quot;&gt; document.write(Math.random());&lt;/script&gt; 运行结果：0.190305486195328 concat()concat() 方法用于连接两个或多个数组。此方法返回一个新数组，不改变原来的数组。 语法 arrayObject.concat(array1,array2,…,arrayN) array1：要连接的第一个数组arrayN：要连接的第N个数组 注意: 该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。 创建一个数组，将把 concat() 中的参数连接到数组 myarr 中，代码如下： 12345678&lt;script type=&quot;text/javascript&quot;&gt; var mya = new Array(3); mya[0] = &quot;1&quot;; mya[1] = &quot;2&quot;; mya[2] = &quot;3&quot;; document.write(mya.concat(4,5)+&quot;&lt;br&gt;&quot;); document.write(mya); &lt;/script&gt; 运行结果：1,2,3,4,51,2,3 我们创建了三个数组，然后使用 concat() 把它们连接起来，代码如下：1234567&lt;script type=&quot;text/javascript&quot;&gt; var mya1= new Array(&quot;hello!&quot;) var mya2= new Array(&quot;I&quot;,&quot;love&quot;); var mya3= new Array(&quot;JavaScript&quot;,&quot;!&quot;); var mya4=mya1.concat(mya2,mya3); document.write(mya4);&lt;/script&gt; 运行结果：hello!,I,love,JavaScript,! join()join()方法用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的。 语法： arrayObject.join(分隔符) 参数：可选，使用要指定的分隔符，如果忽略，则使用逗号做分隔符 例如： 1234var myarr1= new Array(&quot;86&quot;,&quot;010&quot;)var myarr2= new Array(&quot;84697581&quot;);var myarr3= myarr1.concat(myarr2);document.write(myarr3.join(&apos;-&apos;)) 运行结果：86-010-84697581 reverse()reverse() 方法用于颠倒数组中元素的顺序。 语法： arrayObject.reverse() 例如： 1234&lt;script type=&quot;text/javascript&quot;&gt; var myarr1= [1,2,3]; document.write(myarr1.reverse())&lt;/script&gt; 运行结果：3,2,1 注意：该方法会改变原来的数组，而不会创建新的数组。 slice()slice() 方法可从已有的数组中返回选定的元素。 语法 arrayObject.slice(start,end) 参数：start：必填，从何处开始选取。如果是负值。则从数组尾部位置开始选，例如-1倒数第一。end：可选，从何处结束选取，如果是负值，则从数组尾部位置开始选。如果忽略，则切分的数组从start到结束的所有元素。 返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。 .该方法并不会修改数组，而是返回一个子数组。 例如 123456&lt;script type=&quot;text/javascript&quot;&gt; var myarr1= &apos;ABC&apos;; //字符串 document.write(myarr1.slice(1) + &apos;&lt;br/&gt;&apos;); var myarr2= [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;] //数组 document.write(myarr2.slice(1,2));&lt;/script&gt; 运行结果：BCB 注意：1. 可使用负值从数组的尾部选取元素。2.如果 end 未被规定，那么 slice() 方法会选取从 start 到数组结尾的所有元素。3. String.slice() 与 Array.slice() 相似。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于vue环境配置]]></title>
    <url>%2F2017%2F10%2F17%2Fvuetext%2F</url>
    <content type="text"><![CDATA[1.安装node.js在node.js官网根据情况下载（Windows 系统 (.msi) 64位），选择安装路径后一直next下去 ，最后点击 Finish完成。 2.利用淘宝npm镜像安装相关依赖开始 》输入“cmd” ，打开。输入npm install –registry=https://registry.npm.taobao.org 回车安装 3.安装全局vue-cli脚手架在现在cmd这个命令窗口，执行npm install -g vue-cli输入：vue，回车，若出现vue信息说明表示成功 4.建一个文件夹新建一个文件夹，按住shift健，然后在文件夹上点右键 右键上，有个在当前文件夹打开命令行窗口之类的，然后构建项目，执行 vue init webpack vuetest 可按下图操作 5.命令npm run dev 6.在浏览里输入：localhost:8080(默认端口为8080) 注意注意：如不成功，则重复输入 npm install –registry=https://registry.npm.taobao.orgnpm用这个命令进行安装选择高版本node.js安装]]></content>
      <categories>
        <category>工具/环境搭建</category>
      </categories>
      <tags>
        <tag>工具/环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于node.js和gulp配置环境问题]]></title>
    <url>%2F2017%2F03%2F17%2FEnvironment%2F</url>
    <content type="text"><![CDATA[前段时间接触ajax的时候发现笔记本的配置环境出了问题，很不方便。用apache配置略繁琐，考虑到不是大型项目，用node.js配置就够了。查找资料后研究了好久，总是安装好了，记录一下步骤，记忆不好以防日后需要。 1.安装node.j在node.js官网根据情况下载（Windows 系统 (.msi) 64位），选择安装路径后一直next下去 ，最后点击 Finish完成。 2.打开cmd开始 》输入“cmd” ，打开。输入“path” 查看环境变量是否已安装了node.js。 然后输入”node –version”、”npm -version” 查看node.js版本 3.新建存放文件先在E盘(任意盘)新建一个“webserver”（任意命名）的文件，然后在里面新建一个src文件。再src里面新建5个文件并命名。将gulp配置文件package.json、gulpfile.js 等文件下载后放到“webserver”下面。gulpfile.js配置文件下载然后在cmd输入“npm install gulp -g” 回车安装插件。安装之后再输入npm install回车。安装后，再看下webserver文件里面会多出一个‘’node_modules”文件，总算安装成功。 4.打开webserver gulpfile.js文件修改先在E盘(任意盘)新建一个“webserver”（任意命名）的文件，然后在里面新建一个src文件。再src里面新建5个文件并命名。把这个位置的代码删掉，改成： 1server: &#123;baseDir: &apos;./&apos;&#125;,//根目录启动服务器 看到一个前端博客写如果没有打开iis服务器的话就要修改…..emm..没安装 跟着贴过去好了 5.打开Node.js command prompt 输入 gulp+回车，浏览器自动弹出。 这时“webserver”下多了一个”dist”文件。 配置环境成功。把项目放在src里面看下 总结 1.之前配置环境失败原因大概就是cmd路径填写错误和缺失配置文件导致，还有在最后一步输入gulp的时候把cmd关了导致。 2.关于webserver下关于新建src文件的问题。一开始没新建 ，项目放在“webserver”下也可以在本地服务器查看到。但如果修改文件后保存，浏览器不能自动预览。 src文件用来放置项目后，修改代码保存后浏览器自动预览,自动合并压缩文件放到dist文件下。]]></content>
      <categories>
        <category>工具/环境搭建</category>
      </categories>
      <tags>
        <tag>工具/环境搭建</tag>
      </tags>
  </entry>
</search>
